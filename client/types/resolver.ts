import {
  GraphQLResolveInfo,
  GraphQLScalarType,
  GraphQLScalarTypeConfig,
} from 'graphql';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
export type RequireFields<T, K extends keyof T> = Omit<T, K> & {
  [P in K]-?: NonNullable<T[P]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  Cursor: any;
  Time: any;
  Upload: any;
};

export type Account = Node & {
  __typename?: 'Account';
  age: Scalars['Int'];
  avatar: Scalars['String'];
  comments?: Maybe<Array<Comment>>;
  createdAt: Scalars['Time'];
  email: Scalars['String'];
  friends?: Maybe<Array<Account>>;
  friendship?: Maybe<Array<Friend>>;
  gender: AccountGender;
  id: Scalars['ID'];
  introduction: Scalars['String'];
  likes?: Maybe<Array<Like>>;
  mutes?: Maybe<Array<Account>>;
  mutetarget?: Maybe<Array<Mute>>;
  name: Scalars['String'];
  password: Scalars['String'];
  posts?: Maybe<Array<Post>>;
  requests?: Maybe<Array<Account>>;
  requesttarget?: Maybe<Array<Request>>;
  session?: Maybe<Array<Session>>;
  type: AccountType;
  updatedAt: Scalars['Time'];
};

/** AccountGender is enum for the field gender */
export enum AccountGender {
  Female = 'FEMALE',
  Male = 'MALE',
  None = 'NONE',
}

/** AccountType is enum for the field type */
export enum AccountType {
  Active = 'ACTIVE',
  Admin = 'ADMIN',
  Inactive = 'INACTIVE',
}

/**
 * AccountWhereInput is used for filtering Account objects.
 * Input was generated by ent.
 */
export type AccountWhereInput = {
  /** age field predicates */
  age?: InputMaybe<Scalars['Int']>;
  ageGT?: InputMaybe<Scalars['Int']>;
  ageGTE?: InputMaybe<Scalars['Int']>;
  ageIn?: InputMaybe<Array<Scalars['Int']>>;
  ageLT?: InputMaybe<Scalars['Int']>;
  ageLTE?: InputMaybe<Scalars['Int']>;
  ageNEQ?: InputMaybe<Scalars['Int']>;
  ageNotIn?: InputMaybe<Array<Scalars['Int']>>;
  and?: InputMaybe<Array<AccountWhereInput>>;
  /** avatar field predicates */
  avatar?: InputMaybe<Scalars['String']>;
  avatarContains?: InputMaybe<Scalars['String']>;
  avatarContainsFold?: InputMaybe<Scalars['String']>;
  avatarEqualFold?: InputMaybe<Scalars['String']>;
  avatarGT?: InputMaybe<Scalars['String']>;
  avatarGTE?: InputMaybe<Scalars['String']>;
  avatarHasPrefix?: InputMaybe<Scalars['String']>;
  avatarHasSuffix?: InputMaybe<Scalars['String']>;
  avatarIn?: InputMaybe<Array<Scalars['String']>>;
  avatarLT?: InputMaybe<Scalars['String']>;
  avatarLTE?: InputMaybe<Scalars['String']>;
  avatarNEQ?: InputMaybe<Scalars['String']>;
  avatarNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** email field predicates */
  email?: InputMaybe<Scalars['String']>;
  emailContains?: InputMaybe<Scalars['String']>;
  emailContainsFold?: InputMaybe<Scalars['String']>;
  emailEqualFold?: InputMaybe<Scalars['String']>;
  emailGT?: InputMaybe<Scalars['String']>;
  emailGTE?: InputMaybe<Scalars['String']>;
  emailHasPrefix?: InputMaybe<Scalars['String']>;
  emailHasSuffix?: InputMaybe<Scalars['String']>;
  emailIn?: InputMaybe<Array<Scalars['String']>>;
  emailLT?: InputMaybe<Scalars['String']>;
  emailLTE?: InputMaybe<Scalars['String']>;
  emailNEQ?: InputMaybe<Scalars['String']>;
  emailNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** gender field predicates */
  gender?: InputMaybe<AccountGender>;
  genderIn?: InputMaybe<Array<AccountGender>>;
  genderNEQ?: InputMaybe<AccountGender>;
  genderNotIn?: InputMaybe<Array<AccountGender>>;
  /** comments edge predicates */
  hasComments?: InputMaybe<Scalars['Boolean']>;
  hasCommentsWith?: InputMaybe<Array<CommentWhereInput>>;
  /** friends edge predicates */
  hasFriends?: InputMaybe<Scalars['Boolean']>;
  hasFriendsWith?: InputMaybe<Array<AccountWhereInput>>;
  /** friendship edge predicates */
  hasFriendship?: InputMaybe<Scalars['Boolean']>;
  hasFriendshipWith?: InputMaybe<Array<FriendWhereInput>>;
  /** likes edge predicates */
  hasLikes?: InputMaybe<Scalars['Boolean']>;
  hasLikesWith?: InputMaybe<Array<LikeWhereInput>>;
  /** muteTarget edge predicates */
  hasMuteTarget?: InputMaybe<Scalars['Boolean']>;
  hasMuteTargetWith?: InputMaybe<Array<MuteWhereInput>>;
  /** mutes edge predicates */
  hasMutes?: InputMaybe<Scalars['Boolean']>;
  hasMutesWith?: InputMaybe<Array<AccountWhereInput>>;
  /** posts edge predicates */
  hasPosts?: InputMaybe<Scalars['Boolean']>;
  hasPostsWith?: InputMaybe<Array<PostWhereInput>>;
  /** requestTarget edge predicates */
  hasRequestTarget?: InputMaybe<Scalars['Boolean']>;
  hasRequestTargetWith?: InputMaybe<Array<RequestWhereInput>>;
  /** requests edge predicates */
  hasRequests?: InputMaybe<Scalars['Boolean']>;
  hasRequestsWith?: InputMaybe<Array<AccountWhereInput>>;
  /** session edge predicates */
  hasSession?: InputMaybe<Scalars['Boolean']>;
  hasSessionWith?: InputMaybe<Array<SessionWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** introduction field predicates */
  introduction?: InputMaybe<Scalars['String']>;
  introductionContains?: InputMaybe<Scalars['String']>;
  introductionContainsFold?: InputMaybe<Scalars['String']>;
  introductionEqualFold?: InputMaybe<Scalars['String']>;
  introductionGT?: InputMaybe<Scalars['String']>;
  introductionGTE?: InputMaybe<Scalars['String']>;
  introductionHasPrefix?: InputMaybe<Scalars['String']>;
  introductionHasSuffix?: InputMaybe<Scalars['String']>;
  introductionIn?: InputMaybe<Array<Scalars['String']>>;
  introductionLT?: InputMaybe<Scalars['String']>;
  introductionLTE?: InputMaybe<Scalars['String']>;
  introductionNEQ?: InputMaybe<Scalars['String']>;
  introductionNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<AccountWhereInput>;
  or?: InputMaybe<Array<AccountWhereInput>>;
  /** password field predicates */
  password?: InputMaybe<Scalars['String']>;
  passwordContains?: InputMaybe<Scalars['String']>;
  passwordContainsFold?: InputMaybe<Scalars['String']>;
  passwordEqualFold?: InputMaybe<Scalars['String']>;
  passwordGT?: InputMaybe<Scalars['String']>;
  passwordGTE?: InputMaybe<Scalars['String']>;
  passwordHasPrefix?: InputMaybe<Scalars['String']>;
  passwordHasSuffix?: InputMaybe<Scalars['String']>;
  passwordIn?: InputMaybe<Array<Scalars['String']>>;
  passwordLT?: InputMaybe<Scalars['String']>;
  passwordLTE?: InputMaybe<Scalars['String']>;
  passwordNEQ?: InputMaybe<Scalars['String']>;
  passwordNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** type field predicates */
  type?: InputMaybe<AccountType>;
  typeIn?: InputMaybe<Array<AccountType>>;
  typeNEQ?: InputMaybe<AccountType>;
  typeNotIn?: InputMaybe<Array<AccountType>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

export type Comment = Node & {
  __typename?: 'Comment';
  account: Account;
  accountID: Scalars['ID'];
  body: Scalars['String'];
  createdAt: Scalars['Time'];
  id: Scalars['ID'];
  post: Post;
  postID: Scalars['ID'];
  updatedAt: Scalars['Time'];
};

/**
 * CommentWhereInput is used for filtering Comment objects.
 * Input was generated by ent.
 */
export type CommentWhereInput = {
  /** account_id field predicates */
  accountID?: InputMaybe<Scalars['ID']>;
  accountIDIn?: InputMaybe<Array<Scalars['ID']>>;
  accountIDNEQ?: InputMaybe<Scalars['ID']>;
  accountIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  and?: InputMaybe<Array<CommentWhereInput>>;
  /** body field predicates */
  body?: InputMaybe<Scalars['String']>;
  bodyContains?: InputMaybe<Scalars['String']>;
  bodyContainsFold?: InputMaybe<Scalars['String']>;
  bodyEqualFold?: InputMaybe<Scalars['String']>;
  bodyGT?: InputMaybe<Scalars['String']>;
  bodyGTE?: InputMaybe<Scalars['String']>;
  bodyHasPrefix?: InputMaybe<Scalars['String']>;
  bodyHasSuffix?: InputMaybe<Scalars['String']>;
  bodyIn?: InputMaybe<Array<Scalars['String']>>;
  bodyLT?: InputMaybe<Scalars['String']>;
  bodyLTE?: InputMaybe<Scalars['String']>;
  bodyNEQ?: InputMaybe<Scalars['String']>;
  bodyNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** account edge predicates */
  hasAccount?: InputMaybe<Scalars['Boolean']>;
  hasAccountWith?: InputMaybe<Array<AccountWhereInput>>;
  /** post edge predicates */
  hasPost?: InputMaybe<Scalars['Boolean']>;
  hasPostWith?: InputMaybe<Array<PostWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<CommentWhereInput>;
  or?: InputMaybe<Array<CommentWhereInput>>;
  /** post_id field predicates */
  postID?: InputMaybe<Scalars['ID']>;
  postIDIn?: InputMaybe<Array<Scalars['ID']>>;
  postIDNEQ?: InputMaybe<Scalars['ID']>;
  postIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

/**
 * CreateAccountInput is used for create Account object.
 * Input was generated by ent.
 */
export type CreateAccountInput = {
  age: Scalars['Int'];
  avatar: Scalars['String'];
  commentIDs?: InputMaybe<Array<Scalars['ID']>>;
  createdAt?: InputMaybe<Scalars['Time']>;
  email: Scalars['String'];
  friendIDs?: InputMaybe<Array<Scalars['ID']>>;
  gender: AccountGender;
  introduction: Scalars['String'];
  likeIDs?: InputMaybe<Array<Scalars['ID']>>;
  muteIDs?: InputMaybe<Array<Scalars['ID']>>;
  name: Scalars['String'];
  password: Scalars['String'];
  postIDs?: InputMaybe<Array<Scalars['ID']>>;
  requestIDs?: InputMaybe<Array<Scalars['ID']>>;
  sessionIDs?: InputMaybe<Array<Scalars['ID']>>;
  type: AccountType;
  updatedAt?: InputMaybe<Scalars['Time']>;
};

/**
 * CreateCommentInput is used for create Comment object.
 * Input was generated by ent.
 */
export type CreateCommentInput = {
  accountID: Scalars['ID'];
  body: Scalars['String'];
  createdAt?: InputMaybe<Scalars['Time']>;
  postID: Scalars['ID'];
  updatedAt?: InputMaybe<Scalars['Time']>;
};

/**
 * CreateFriendInput is used for create Friend object.
 * Input was generated by ent.
 */
export type CreateFriendInput = {
  accountID: Scalars['ID'];
  createdAt?: InputMaybe<Scalars['Time']>;
  friendID: Scalars['ID'];
  updatedAt?: InputMaybe<Scalars['Time']>;
};

/**
 * CreateLikeInput is used for create Like object.
 * Input was generated by ent.
 */
export type CreateLikeInput = {
  accountID: Scalars['ID'];
  createdAt?: InputMaybe<Scalars['Time']>;
  postID: Scalars['ID'];
  updatedAt?: InputMaybe<Scalars['Time']>;
};

/**
 * CreateMarkerInput is used for create Marker object.
 * Input was generated by ent.
 */
export type CreateMarkerInput = {
  createdAt?: InputMaybe<Scalars['Time']>;
  lat: Scalars['String'];
  lng: Scalars['String'];
  postID: Scalars['ID'];
  title: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['Time']>;
};

/**
 * CreateMuteInput is used for create Mute object.
 * Input was generated by ent.
 */
export type CreateMuteInput = {
  accountID: Scalars['ID'];
  createdAt?: InputMaybe<Scalars['Time']>;
  muteID: Scalars['ID'];
  updatedAt?: InputMaybe<Scalars['Time']>;
};

/**
 * CreatePostInput is used for create Post object.
 * Input was generated by ent.
 */
export type CreatePostInput = {
  accountID: Scalars['ID'];
  body: Scalars['String'];
  commentIDs?: InputMaybe<Array<Scalars['ID']>>;
  createdAt?: InputMaybe<Scalars['Time']>;
  img: Scalars['String'];
  likeIDs?: InputMaybe<Array<Scalars['ID']>>;
  markerID?: InputMaybe<Scalars['ID']>;
  title: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['Time']>;
};

/**
 * CreateRequestInput is used for create Request object.
 * Input was generated by ent.
 */
export type CreateRequestInput = {
  accountID: Scalars['ID'];
  createdAt?: InputMaybe<Scalars['Time']>;
  requestID: Scalars['ID'];
  status: RequestStatus;
  updatedAt?: InputMaybe<Scalars['Time']>;
};

/**
 * CreateSessionInput is used for create Session object.
 * Input was generated by ent.
 */
export type CreateSessionInput = {
  accountID: Scalars['ID'];
  createdAt?: InputMaybe<Scalars['Time']>;
  session: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['Time']>;
};

export type Friend = Node & {
  __typename?: 'Friend';
  account: Account;
  accountID: Scalars['ID'];
  createdAt: Scalars['Time'];
  friend: Account;
  friendID: Scalars['ID'];
  id: Scalars['ID'];
  updatedAt: Scalars['Time'];
};

/**
 * FriendWhereInput is used for filtering Friend objects.
 * Input was generated by ent.
 */
export type FriendWhereInput = {
  and?: InputMaybe<Array<FriendWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<FriendWhereInput>;
  or?: InputMaybe<Array<FriendWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

export type Like = Node & {
  __typename?: 'Like';
  account: Account;
  accountID: Scalars['ID'];
  createdAt: Scalars['Time'];
  id: Scalars['ID'];
  post: Post;
  postID: Scalars['ID'];
  updatedAt: Scalars['Time'];
};

/**
 * LikeWhereInput is used for filtering Like objects.
 * Input was generated by ent.
 */
export type LikeWhereInput = {
  /** account_id field predicates */
  accountID?: InputMaybe<Scalars['ID']>;
  accountIDIn?: InputMaybe<Array<Scalars['ID']>>;
  accountIDNEQ?: InputMaybe<Scalars['ID']>;
  accountIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  and?: InputMaybe<Array<LikeWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** account edge predicates */
  hasAccount?: InputMaybe<Scalars['Boolean']>;
  hasAccountWith?: InputMaybe<Array<AccountWhereInput>>;
  /** post edge predicates */
  hasPost?: InputMaybe<Scalars['Boolean']>;
  hasPostWith?: InputMaybe<Array<PostWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<LikeWhereInput>;
  or?: InputMaybe<Array<LikeWhereInput>>;
  /** post_id field predicates */
  postID?: InputMaybe<Scalars['ID']>;
  postIDIn?: InputMaybe<Array<Scalars['ID']>>;
  postIDNEQ?: InputMaybe<Scalars['ID']>;
  postIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

export type Marker = Node & {
  __typename?: 'Marker';
  createdAt: Scalars['Time'];
  id: Scalars['ID'];
  lat: Scalars['String'];
  lng: Scalars['String'];
  post: Post;
  postID: Scalars['ID'];
  title: Scalars['String'];
  updatedAt: Scalars['Time'];
};

/**
 * MarkerWhereInput is used for filtering Marker objects.
 * Input was generated by ent.
 */
export type MarkerWhereInput = {
  and?: InputMaybe<Array<MarkerWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** post edge predicates */
  hasPost?: InputMaybe<Scalars['Boolean']>;
  hasPostWith?: InputMaybe<Array<PostWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** lat field predicates */
  lat?: InputMaybe<Scalars['String']>;
  latContains?: InputMaybe<Scalars['String']>;
  latContainsFold?: InputMaybe<Scalars['String']>;
  latEqualFold?: InputMaybe<Scalars['String']>;
  latGT?: InputMaybe<Scalars['String']>;
  latGTE?: InputMaybe<Scalars['String']>;
  latHasPrefix?: InputMaybe<Scalars['String']>;
  latHasSuffix?: InputMaybe<Scalars['String']>;
  latIn?: InputMaybe<Array<Scalars['String']>>;
  latLT?: InputMaybe<Scalars['String']>;
  latLTE?: InputMaybe<Scalars['String']>;
  latNEQ?: InputMaybe<Scalars['String']>;
  latNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** lng field predicates */
  lng?: InputMaybe<Scalars['String']>;
  lngContains?: InputMaybe<Scalars['String']>;
  lngContainsFold?: InputMaybe<Scalars['String']>;
  lngEqualFold?: InputMaybe<Scalars['String']>;
  lngGT?: InputMaybe<Scalars['String']>;
  lngGTE?: InputMaybe<Scalars['String']>;
  lngHasPrefix?: InputMaybe<Scalars['String']>;
  lngHasSuffix?: InputMaybe<Scalars['String']>;
  lngIn?: InputMaybe<Array<Scalars['String']>>;
  lngLT?: InputMaybe<Scalars['String']>;
  lngLTE?: InputMaybe<Scalars['String']>;
  lngNEQ?: InputMaybe<Scalars['String']>;
  lngNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<MarkerWhereInput>;
  or?: InputMaybe<Array<MarkerWhereInput>>;
  /** post_id field predicates */
  postID?: InputMaybe<Scalars['ID']>;
  postIDIn?: InputMaybe<Array<Scalars['ID']>>;
  postIDNEQ?: InputMaybe<Scalars['ID']>;
  postIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']>;
  titleContains?: InputMaybe<Scalars['String']>;
  titleContainsFold?: InputMaybe<Scalars['String']>;
  titleEqualFold?: InputMaybe<Scalars['String']>;
  titleGT?: InputMaybe<Scalars['String']>;
  titleGTE?: InputMaybe<Scalars['String']>;
  titleHasPrefix?: InputMaybe<Scalars['String']>;
  titleHasSuffix?: InputMaybe<Scalars['String']>;
  titleIn?: InputMaybe<Array<Scalars['String']>>;
  titleLT?: InputMaybe<Scalars['String']>;
  titleLTE?: InputMaybe<Scalars['String']>;
  titleNEQ?: InputMaybe<Scalars['String']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

export type Mutation = {
  __typename?: 'Mutation';
  CreateAccount: Account;
  CreateComment: Comment;
  CreateFriend: Friend;
  CreateLike: Like;
  CreateMarker: Marker;
  CreateMute: Mute;
  CreatePost: Post;
  CreateRequest: Request;
  CreateSession: Session;
  DeleteAccount: Account;
  DeleteComment: Comment;
  DeleteFriend: Friend;
  DeleteLike: Like;
  DeleteMarker: Marker;
  DeleteMute: Mute;
  DeletePost: Post;
  DeleteRequest: Request;
  DeleteSession: Session;
  UpdateAccount: Account;
  UpdateComment: Comment;
  UpdateMarker: Marker;
  UpdatePost: Post;
  UpdateRequest: Request;
  UpdateSession: Session;
};

export type MutationCreateAccountArgs = {
  input: CreateAccountInput;
};

export type MutationCreateCommentArgs = {
  input: CreateCommentInput;
};

export type MutationCreateFriendArgs = {
  input: CreateFriendInput;
};

export type MutationCreateLikeArgs = {
  input: CreateLikeInput;
};

export type MutationCreateMarkerArgs = {
  input: CreateMarkerInput;
};

export type MutationCreateMuteArgs = {
  input: CreateMuteInput;
};

export type MutationCreatePostArgs = {
  input: CreatePostInput;
};

export type MutationCreateRequestArgs = {
  input: CreateRequestInput;
};

export type MutationCreateSessionArgs = {
  input: CreateSessionInput;
};

export type MutationDeleteAccountArgs = {
  id: Scalars['ID'];
};

export type MutationDeleteCommentArgs = {
  id: Scalars['ID'];
};

export type MutationDeleteFriendArgs = {
  id: Scalars['ID'];
};

export type MutationDeleteLikeArgs = {
  id: Scalars['ID'];
};

export type MutationDeleteMarkerArgs = {
  id: Scalars['ID'];
};

export type MutationDeleteMuteArgs = {
  id: Scalars['ID'];
};

export type MutationDeletePostArgs = {
  id: Scalars['ID'];
};

export type MutationDeleteRequestArgs = {
  id: Scalars['ID'];
};

export type MutationDeleteSessionArgs = {
  id: Scalars['ID'];
};

export type MutationUpdateAccountArgs = {
  id: Scalars['ID'];
  input: UpdateAccountInput;
};

export type MutationUpdateCommentArgs = {
  id: Scalars['ID'];
  input: UpdateCommentInput;
};

export type MutationUpdateMarkerArgs = {
  id: Scalars['ID'];
  input: UpdateMarkerInput;
};

export type MutationUpdatePostArgs = {
  id: Scalars['ID'];
  input: UpdatePostInput;
};

export type MutationUpdateRequestArgs = {
  id: Scalars['ID'];
  input: UpdateRequestInput;
};

export type MutationUpdateSessionArgs = {
  id: Scalars['ID'];
  input: UpdateSessionInput;
};

export type Mute = Node & {
  __typename?: 'Mute';
  account: Account;
  accountID: Scalars['ID'];
  createdAt: Scalars['Time'];
  id: Scalars['ID'];
  mute: Account;
  muteID: Scalars['ID'];
  updatedAt: Scalars['Time'];
};

/**
 * MuteWhereInput is used for filtering Mute objects.
 * Input was generated by ent.
 */
export type MuteWhereInput = {
  and?: InputMaybe<Array<MuteWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<MuteWhereInput>;
  or?: InputMaybe<Array<MuteWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID'];
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC',
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']>;
};

export type Post = Node & {
  __typename?: 'Post';
  account: Account;
  accountID: Scalars['ID'];
  body: Scalars['String'];
  comments?: Maybe<Array<Comment>>;
  createdAt: Scalars['Time'];
  id: Scalars['ID'];
  img: Scalars['String'];
  likes?: Maybe<Array<Like>>;
  marker?: Maybe<Marker>;
  title: Scalars['String'];
  updatedAt: Scalars['Time'];
};

/**
 * PostWhereInput is used for filtering Post objects.
 * Input was generated by ent.
 */
export type PostWhereInput = {
  /** account_id field predicates */
  accountID?: InputMaybe<Scalars['ID']>;
  accountIDIn?: InputMaybe<Array<Scalars['ID']>>;
  accountIDNEQ?: InputMaybe<Scalars['ID']>;
  accountIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  and?: InputMaybe<Array<PostWhereInput>>;
  /** body field predicates */
  body?: InputMaybe<Scalars['String']>;
  bodyContains?: InputMaybe<Scalars['String']>;
  bodyContainsFold?: InputMaybe<Scalars['String']>;
  bodyEqualFold?: InputMaybe<Scalars['String']>;
  bodyGT?: InputMaybe<Scalars['String']>;
  bodyGTE?: InputMaybe<Scalars['String']>;
  bodyHasPrefix?: InputMaybe<Scalars['String']>;
  bodyHasSuffix?: InputMaybe<Scalars['String']>;
  bodyIn?: InputMaybe<Array<Scalars['String']>>;
  bodyLT?: InputMaybe<Scalars['String']>;
  bodyLTE?: InputMaybe<Scalars['String']>;
  bodyNEQ?: InputMaybe<Scalars['String']>;
  bodyNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** account edge predicates */
  hasAccount?: InputMaybe<Scalars['Boolean']>;
  hasAccountWith?: InputMaybe<Array<AccountWhereInput>>;
  /** comments edge predicates */
  hasComments?: InputMaybe<Scalars['Boolean']>;
  hasCommentsWith?: InputMaybe<Array<CommentWhereInput>>;
  /** likes edge predicates */
  hasLikes?: InputMaybe<Scalars['Boolean']>;
  hasLikesWith?: InputMaybe<Array<LikeWhereInput>>;
  /** marker edge predicates */
  hasMarker?: InputMaybe<Scalars['Boolean']>;
  hasMarkerWith?: InputMaybe<Array<MarkerWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** img field predicates */
  img?: InputMaybe<Scalars['String']>;
  imgContains?: InputMaybe<Scalars['String']>;
  imgContainsFold?: InputMaybe<Scalars['String']>;
  imgEqualFold?: InputMaybe<Scalars['String']>;
  imgGT?: InputMaybe<Scalars['String']>;
  imgGTE?: InputMaybe<Scalars['String']>;
  imgHasPrefix?: InputMaybe<Scalars['String']>;
  imgHasSuffix?: InputMaybe<Scalars['String']>;
  imgIn?: InputMaybe<Array<Scalars['String']>>;
  imgLT?: InputMaybe<Scalars['String']>;
  imgLTE?: InputMaybe<Scalars['String']>;
  imgNEQ?: InputMaybe<Scalars['String']>;
  imgNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<PostWhereInput>;
  or?: InputMaybe<Array<PostWhereInput>>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']>;
  titleContains?: InputMaybe<Scalars['String']>;
  titleContainsFold?: InputMaybe<Scalars['String']>;
  titleEqualFold?: InputMaybe<Scalars['String']>;
  titleGT?: InputMaybe<Scalars['String']>;
  titleGTE?: InputMaybe<Scalars['String']>;
  titleHasPrefix?: InputMaybe<Scalars['String']>;
  titleHasSuffix?: InputMaybe<Scalars['String']>;
  titleIn?: InputMaybe<Array<Scalars['String']>>;
  titleLT?: InputMaybe<Scalars['String']>;
  titleLTE?: InputMaybe<Scalars['String']>;
  titleNEQ?: InputMaybe<Scalars['String']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

export type Query = {
  __typename?: 'Query';
  AccountByID: Account;
  AccountBySelfID: Account;
  LikesByPostID: Array<Like>;
  RequestsByAccountID: Array<Request>;
  RequestsByRequestID: Array<Request>;
  SessionByID: Session;
  accounts: Array<Account>;
  comments: Array<Comment>;
  friends: Array<Friend>;
  likes: Array<Like>;
  markers: Array<Marker>;
  mutes: Array<Mute>;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  posts: Array<Post>;
  requests: Array<Request>;
  sessions: Array<Session>;
};

export type QueryAccountByIdArgs = {
  id: Scalars['ID'];
};

export type QueryAccountBySelfIdArgs = {
  id: Scalars['ID'];
};

export type QueryLikesByPostIdArgs = {
  postID: Scalars['ID'];
};

export type QueryRequestsByAccountIdArgs = {
  accountID: Scalars['ID'];
};

export type QueryRequestsByRequestIdArgs = {
  requestID: Scalars['ID'];
};

export type QuerySessionByIdArgs = {
  id: Scalars['ID'];
};

export type QueryNodeArgs = {
  id: Scalars['ID'];
};

export type QueryNodesArgs = {
  ids: Array<Scalars['ID']>;
};

export type Request = Node & {
  __typename?: 'Request';
  account: Account;
  accountID: Scalars['ID'];
  createdAt: Scalars['Time'];
  id: Scalars['ID'];
  request: Account;
  requestID: Scalars['ID'];
  status: RequestStatus;
  updatedAt: Scalars['Time'];
};

/** RequestStatus is enum for the field status */
export enum RequestStatus {
  Accept = 'ACCEPT',
  BreakDeny = 'BREAK_DENY',
  BreakInAccept = 'BREAK_IN_ACCEPT',
  BreakInProcess = 'BREAK_IN_PROCESS',
  Deny = 'DENY',
  InProcess = 'IN_PROCESS',
}

/**
 * RequestWhereInput is used for filtering Request objects.
 * Input was generated by ent.
 */
export type RequestWhereInput = {
  and?: InputMaybe<Array<RequestWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<RequestWhereInput>;
  or?: InputMaybe<Array<RequestWhereInput>>;
  /** status field predicates */
  status?: InputMaybe<RequestStatus>;
  statusIn?: InputMaybe<Array<RequestStatus>>;
  statusNEQ?: InputMaybe<RequestStatus>;
  statusNotIn?: InputMaybe<Array<RequestStatus>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

export type Session = Node & {
  __typename?: 'Session';
  account: Account;
  accountID: Scalars['ID'];
  createdAt: Scalars['Time'];
  id: Scalars['ID'];
  session: Scalars['String'];
  updatedAt: Scalars['Time'];
};

/**
 * SessionWhereInput is used for filtering Session objects.
 * Input was generated by ent.
 */
export type SessionWhereInput = {
  /** account_id field predicates */
  accountID?: InputMaybe<Scalars['ID']>;
  accountIDIn?: InputMaybe<Array<Scalars['ID']>>;
  accountIDNEQ?: InputMaybe<Scalars['ID']>;
  accountIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  and?: InputMaybe<Array<SessionWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** account edge predicates */
  hasAccount?: InputMaybe<Scalars['Boolean']>;
  hasAccountWith?: InputMaybe<Array<AccountWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<SessionWhereInput>;
  or?: InputMaybe<Array<SessionWhereInput>>;
  /** session field predicates */
  session?: InputMaybe<Scalars['String']>;
  sessionContains?: InputMaybe<Scalars['String']>;
  sessionContainsFold?: InputMaybe<Scalars['String']>;
  sessionEqualFold?: InputMaybe<Scalars['String']>;
  sessionGT?: InputMaybe<Scalars['String']>;
  sessionGTE?: InputMaybe<Scalars['String']>;
  sessionHasPrefix?: InputMaybe<Scalars['String']>;
  sessionHasSuffix?: InputMaybe<Scalars['String']>;
  sessionIn?: InputMaybe<Array<Scalars['String']>>;
  sessionLT?: InputMaybe<Scalars['String']>;
  sessionLTE?: InputMaybe<Scalars['String']>;
  sessionNEQ?: InputMaybe<Scalars['String']>;
  sessionNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

/**
 * UpdateAccountInput is used for update Account object.
 * Input was generated by ent.
 */
export type UpdateAccountInput = {
  addCommentIDs?: InputMaybe<Array<Scalars['ID']>>;
  addFriendIDs?: InputMaybe<Array<Scalars['ID']>>;
  addLikeIDs?: InputMaybe<Array<Scalars['ID']>>;
  addMuteIDs?: InputMaybe<Array<Scalars['ID']>>;
  addPostIDs?: InputMaybe<Array<Scalars['ID']>>;
  addRequestIDs?: InputMaybe<Array<Scalars['ID']>>;
  addSessionIDs?: InputMaybe<Array<Scalars['ID']>>;
  age?: InputMaybe<Scalars['Int']>;
  avatar?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  gender?: InputMaybe<AccountGender>;
  introduction?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  password?: InputMaybe<Scalars['String']>;
  removeCommentIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeFriendIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeLikeIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeMuteIDs?: InputMaybe<Array<Scalars['ID']>>;
  removePostIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeRequestIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeSessionIDs?: InputMaybe<Array<Scalars['ID']>>;
  type?: InputMaybe<AccountType>;
  updatedAt?: InputMaybe<Scalars['Time']>;
};

/**
 * UpdateCommentInput is used for update Comment object.
 * Input was generated by ent.
 */
export type UpdateCommentInput = {
  accountID?: InputMaybe<Scalars['ID']>;
  body?: InputMaybe<Scalars['String']>;
  clearAccount?: InputMaybe<Scalars['Boolean']>;
  clearPost?: InputMaybe<Scalars['Boolean']>;
  postID?: InputMaybe<Scalars['ID']>;
  updatedAt?: InputMaybe<Scalars['Time']>;
};

/**
 * UpdateFriendInput is used for update Friend object.
 * Input was generated by ent.
 */
export type UpdateFriendInput = {
  accountID?: InputMaybe<Scalars['ID']>;
  clearAccount?: InputMaybe<Scalars['Boolean']>;
  clearFriend?: InputMaybe<Scalars['Boolean']>;
  friendID?: InputMaybe<Scalars['ID']>;
  updatedAt?: InputMaybe<Scalars['Time']>;
};

/**
 * UpdateLikeInput is used for update Like object.
 * Input was generated by ent.
 */
export type UpdateLikeInput = {
  accountID?: InputMaybe<Scalars['ID']>;
  clearAccount?: InputMaybe<Scalars['Boolean']>;
  clearPost?: InputMaybe<Scalars['Boolean']>;
  postID?: InputMaybe<Scalars['ID']>;
  updatedAt?: InputMaybe<Scalars['Time']>;
};

/**
 * UpdateMarkerInput is used for update Marker object.
 * Input was generated by ent.
 */
export type UpdateMarkerInput = {
  clearPost?: InputMaybe<Scalars['Boolean']>;
  lat?: InputMaybe<Scalars['String']>;
  lng?: InputMaybe<Scalars['String']>;
  postID?: InputMaybe<Scalars['ID']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['Time']>;
};

/**
 * UpdateMuteInput is used for update Mute object.
 * Input was generated by ent.
 */
export type UpdateMuteInput = {
  accountID?: InputMaybe<Scalars['ID']>;
  clearAccount?: InputMaybe<Scalars['Boolean']>;
  clearMute?: InputMaybe<Scalars['Boolean']>;
  muteID?: InputMaybe<Scalars['ID']>;
  updatedAt?: InputMaybe<Scalars['Time']>;
};

/**
 * UpdatePostInput is used for update Post object.
 * Input was generated by ent.
 */
export type UpdatePostInput = {
  accountID?: InputMaybe<Scalars['ID']>;
  addCommentIDs?: InputMaybe<Array<Scalars['ID']>>;
  addLikeIDs?: InputMaybe<Array<Scalars['ID']>>;
  body?: InputMaybe<Scalars['String']>;
  clearAccount?: InputMaybe<Scalars['Boolean']>;
  clearMarker?: InputMaybe<Scalars['Boolean']>;
  img?: InputMaybe<Scalars['String']>;
  markerID?: InputMaybe<Scalars['ID']>;
  removeCommentIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeLikeIDs?: InputMaybe<Array<Scalars['ID']>>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['Time']>;
};

/**
 * UpdateRequestInput is used for update Request object.
 * Input was generated by ent.
 */
export type UpdateRequestInput = {
  accountID?: InputMaybe<Scalars['ID']>;
  clearAccount?: InputMaybe<Scalars['Boolean']>;
  clearRequest?: InputMaybe<Scalars['Boolean']>;
  requestID?: InputMaybe<Scalars['ID']>;
  status?: InputMaybe<RequestStatus>;
  updatedAt?: InputMaybe<Scalars['Time']>;
};

/**
 * UpdateSessionInput is used for update Session object.
 * Input was generated by ent.
 */
export type UpdateSessionInput = {
  accountID?: InputMaybe<Scalars['ID']>;
  clearAccount?: InputMaybe<Scalars['Boolean']>;
  session?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['Time']>;
};

export type WithIndex<TObject> = TObject & Record<string, any>;
export type ResolversObject<TObject> = WithIndex<TObject>;

export type ResolverTypeWrapper<T> = Promise<T> | T;

export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
  | ResolverFn<TResult, TParent, TContext, TArgs>
  | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<
  TResult,
  TKey extends string,
  TParent,
  TContext,
  TArgs,
> {
  subscribe: SubscriptionSubscribeFn<
    { [key in TKey]: TResult },
    TParent,
    TContext,
    TArgs
  >;
  resolve?: SubscriptionResolveFn<
    TResult,
    { [key in TKey]: TResult },
    TContext,
    TArgs
  >;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<
  TResult,
  TKey extends string,
  TParent,
  TContext,
  TArgs,
> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<
  TResult,
  TKey extends string,
  TParent = {},
  TContext = {},
  TArgs = {},
> =
  | ((
      ...args: any[]
    ) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo,
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (
  obj: T,
  context: TContext,
  info: GraphQLResolveInfo,
) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<
  TResult = {},
  TParent = {},
  TContext = {},
  TArgs = {},
> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = ResolversObject<{
  Account: ResolverTypeWrapper<Account>;
  AccountGender: AccountGender;
  AccountType: AccountType;
  AccountWhereInput: AccountWhereInput;
  Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
  Comment: ResolverTypeWrapper<Comment>;
  CommentWhereInput: CommentWhereInput;
  CreateAccountInput: CreateAccountInput;
  CreateCommentInput: CreateCommentInput;
  CreateFriendInput: CreateFriendInput;
  CreateLikeInput: CreateLikeInput;
  CreateMarkerInput: CreateMarkerInput;
  CreateMuteInput: CreateMuteInput;
  CreatePostInput: CreatePostInput;
  CreateRequestInput: CreateRequestInput;
  CreateSessionInput: CreateSessionInput;
  Cursor: ResolverTypeWrapper<Scalars['Cursor']>;
  Float: ResolverTypeWrapper<Scalars['Float']>;
  Friend: ResolverTypeWrapper<Friend>;
  FriendWhereInput: FriendWhereInput;
  ID: ResolverTypeWrapper<Scalars['ID']>;
  Int: ResolverTypeWrapper<Scalars['Int']>;
  Like: ResolverTypeWrapper<Like>;
  LikeWhereInput: LikeWhereInput;
  Marker: ResolverTypeWrapper<Marker>;
  MarkerWhereInput: MarkerWhereInput;
  Mutation: ResolverTypeWrapper<{}>;
  Mute: ResolverTypeWrapper<Mute>;
  MuteWhereInput: MuteWhereInput;
  Node:
    | ResolversTypes['Account']
    | ResolversTypes['Comment']
    | ResolversTypes['Friend']
    | ResolversTypes['Like']
    | ResolversTypes['Marker']
    | ResolversTypes['Mute']
    | ResolversTypes['Post']
    | ResolversTypes['Request']
    | ResolversTypes['Session'];
  OrderDirection: OrderDirection;
  PageInfo: ResolverTypeWrapper<PageInfo>;
  Post: ResolverTypeWrapper<Post>;
  PostWhereInput: PostWhereInput;
  Query: ResolverTypeWrapper<{}>;
  Request: ResolverTypeWrapper<Request>;
  RequestStatus: RequestStatus;
  RequestWhereInput: RequestWhereInput;
  Session: ResolverTypeWrapper<Session>;
  SessionWhereInput: SessionWhereInput;
  String: ResolverTypeWrapper<Scalars['String']>;
  Time: ResolverTypeWrapper<Scalars['Time']>;
  UpdateAccountInput: UpdateAccountInput;
  UpdateCommentInput: UpdateCommentInput;
  UpdateFriendInput: UpdateFriendInput;
  UpdateLikeInput: UpdateLikeInput;
  UpdateMarkerInput: UpdateMarkerInput;
  UpdateMuteInput: UpdateMuteInput;
  UpdatePostInput: UpdatePostInput;
  UpdateRequestInput: UpdateRequestInput;
  UpdateSessionInput: UpdateSessionInput;
  Upload: ResolverTypeWrapper<Scalars['Upload']>;
}>;

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = ResolversObject<{
  Account: Account;
  AccountWhereInput: AccountWhereInput;
  Boolean: Scalars['Boolean'];
  Comment: Comment;
  CommentWhereInput: CommentWhereInput;
  CreateAccountInput: CreateAccountInput;
  CreateCommentInput: CreateCommentInput;
  CreateFriendInput: CreateFriendInput;
  CreateLikeInput: CreateLikeInput;
  CreateMarkerInput: CreateMarkerInput;
  CreateMuteInput: CreateMuteInput;
  CreatePostInput: CreatePostInput;
  CreateRequestInput: CreateRequestInput;
  CreateSessionInput: CreateSessionInput;
  Cursor: Scalars['Cursor'];
  Float: Scalars['Float'];
  Friend: Friend;
  FriendWhereInput: FriendWhereInput;
  ID: Scalars['ID'];
  Int: Scalars['Int'];
  Like: Like;
  LikeWhereInput: LikeWhereInput;
  Marker: Marker;
  MarkerWhereInput: MarkerWhereInput;
  Mutation: {};
  Mute: Mute;
  MuteWhereInput: MuteWhereInput;
  Node:
    | ResolversParentTypes['Account']
    | ResolversParentTypes['Comment']
    | ResolversParentTypes['Friend']
    | ResolversParentTypes['Like']
    | ResolversParentTypes['Marker']
    | ResolversParentTypes['Mute']
    | ResolversParentTypes['Post']
    | ResolversParentTypes['Request']
    | ResolversParentTypes['Session'];
  PageInfo: PageInfo;
  Post: Post;
  PostWhereInput: PostWhereInput;
  Query: {};
  Request: Request;
  RequestWhereInput: RequestWhereInput;
  Session: Session;
  SessionWhereInput: SessionWhereInput;
  String: Scalars['String'];
  Time: Scalars['Time'];
  UpdateAccountInput: UpdateAccountInput;
  UpdateCommentInput: UpdateCommentInput;
  UpdateFriendInput: UpdateFriendInput;
  UpdateLikeInput: UpdateLikeInput;
  UpdateMarkerInput: UpdateMarkerInput;
  UpdateMuteInput: UpdateMuteInput;
  UpdatePostInput: UpdatePostInput;
  UpdateRequestInput: UpdateRequestInput;
  UpdateSessionInput: UpdateSessionInput;
  Upload: Scalars['Upload'];
}>;

export type GoFieldDirectiveArgs = {
  forceResolver?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
};

export type GoFieldDirectiveResolver<
  Result,
  Parent,
  ContextType = any,
  Args = GoFieldDirectiveArgs,
> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type GoModelDirectiveArgs = {
  model?: Maybe<Scalars['String']>;
  models?: Maybe<Array<Scalars['String']>>;
};

export type GoModelDirectiveResolver<
  Result,
  Parent,
  ContextType = any,
  Args = GoModelDirectiveArgs,
> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type AccountResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['Account'] = ResolversParentTypes['Account'],
> = ResolversObject<{
  age?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  avatar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  comments?: Resolver<
    Maybe<Array<ResolversTypes['Comment']>>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  friends?: Resolver<
    Maybe<Array<ResolversTypes['Account']>>,
    ParentType,
    ContextType
  >;
  friendship?: Resolver<
    Maybe<Array<ResolversTypes['Friend']>>,
    ParentType,
    ContextType
  >;
  gender?: Resolver<ResolversTypes['AccountGender'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  introduction?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  likes?: Resolver<
    Maybe<Array<ResolversTypes['Like']>>,
    ParentType,
    ContextType
  >;
  mutes?: Resolver<
    Maybe<Array<ResolversTypes['Account']>>,
    ParentType,
    ContextType
  >;
  mutetarget?: Resolver<
    Maybe<Array<ResolversTypes['Mute']>>,
    ParentType,
    ContextType
  >;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  password?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  posts?: Resolver<
    Maybe<Array<ResolversTypes['Post']>>,
    ParentType,
    ContextType
  >;
  requests?: Resolver<
    Maybe<Array<ResolversTypes['Account']>>,
    ParentType,
    ContextType
  >;
  requesttarget?: Resolver<
    Maybe<Array<ResolversTypes['Request']>>,
    ParentType,
    ContextType
  >;
  session?: Resolver<
    Maybe<Array<ResolversTypes['Session']>>,
    ParentType,
    ContextType
  >;
  type?: Resolver<ResolversTypes['AccountType'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CommentResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['Comment'] = ResolversParentTypes['Comment'],
> = ResolversObject<{
  account?: Resolver<ResolversTypes['Account'], ParentType, ContextType>;
  accountID?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  post?: Resolver<ResolversTypes['Post'], ParentType, ContextType>;
  postID?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface CursorScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes['Cursor'], any> {
  name: 'Cursor';
}

export type FriendResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['Friend'] = ResolversParentTypes['Friend'],
> = ResolversObject<{
  account?: Resolver<ResolversTypes['Account'], ParentType, ContextType>;
  accountID?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  friend?: Resolver<ResolversTypes['Account'], ParentType, ContextType>;
  friendID?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LikeResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['Like'] = ResolversParentTypes['Like'],
> = ResolversObject<{
  account?: Resolver<ResolversTypes['Account'], ParentType, ContextType>;
  accountID?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  post?: Resolver<ResolversTypes['Post'], ParentType, ContextType>;
  postID?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MarkerResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['Marker'] = ResolversParentTypes['Marker'],
> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  lat?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lng?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  post?: Resolver<ResolversTypes['Post'], ParentType, ContextType>;
  postID?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MutationResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation'],
> = ResolversObject<{
  CreateAccount?: Resolver<
    ResolversTypes['Account'],
    ParentType,
    ContextType,
    RequireFields<MutationCreateAccountArgs, 'input'>
  >;
  CreateComment?: Resolver<
    ResolversTypes['Comment'],
    ParentType,
    ContextType,
    RequireFields<MutationCreateCommentArgs, 'input'>
  >;
  CreateFriend?: Resolver<
    ResolversTypes['Friend'],
    ParentType,
    ContextType,
    RequireFields<MutationCreateFriendArgs, 'input'>
  >;
  CreateLike?: Resolver<
    ResolversTypes['Like'],
    ParentType,
    ContextType,
    RequireFields<MutationCreateLikeArgs, 'input'>
  >;
  CreateMarker?: Resolver<
    ResolversTypes['Marker'],
    ParentType,
    ContextType,
    RequireFields<MutationCreateMarkerArgs, 'input'>
  >;
  CreateMute?: Resolver<
    ResolversTypes['Mute'],
    ParentType,
    ContextType,
    RequireFields<MutationCreateMuteArgs, 'input'>
  >;
  CreatePost?: Resolver<
    ResolversTypes['Post'],
    ParentType,
    ContextType,
    RequireFields<MutationCreatePostArgs, 'input'>
  >;
  CreateRequest?: Resolver<
    ResolversTypes['Request'],
    ParentType,
    ContextType,
    RequireFields<MutationCreateRequestArgs, 'input'>
  >;
  CreateSession?: Resolver<
    ResolversTypes['Session'],
    ParentType,
    ContextType,
    RequireFields<MutationCreateSessionArgs, 'input'>
  >;
  DeleteAccount?: Resolver<
    ResolversTypes['Account'],
    ParentType,
    ContextType,
    RequireFields<MutationDeleteAccountArgs, 'id'>
  >;
  DeleteComment?: Resolver<
    ResolversTypes['Comment'],
    ParentType,
    ContextType,
    RequireFields<MutationDeleteCommentArgs, 'id'>
  >;
  DeleteFriend?: Resolver<
    ResolversTypes['Friend'],
    ParentType,
    ContextType,
    RequireFields<MutationDeleteFriendArgs, 'id'>
  >;
  DeleteLike?: Resolver<
    ResolversTypes['Like'],
    ParentType,
    ContextType,
    RequireFields<MutationDeleteLikeArgs, 'id'>
  >;
  DeleteMarker?: Resolver<
    ResolversTypes['Marker'],
    ParentType,
    ContextType,
    RequireFields<MutationDeleteMarkerArgs, 'id'>
  >;
  DeleteMute?: Resolver<
    ResolversTypes['Mute'],
    ParentType,
    ContextType,
    RequireFields<MutationDeleteMuteArgs, 'id'>
  >;
  DeletePost?: Resolver<
    ResolversTypes['Post'],
    ParentType,
    ContextType,
    RequireFields<MutationDeletePostArgs, 'id'>
  >;
  DeleteRequest?: Resolver<
    ResolversTypes['Request'],
    ParentType,
    ContextType,
    RequireFields<MutationDeleteRequestArgs, 'id'>
  >;
  DeleteSession?: Resolver<
    ResolversTypes['Session'],
    ParentType,
    ContextType,
    RequireFields<MutationDeleteSessionArgs, 'id'>
  >;
  UpdateAccount?: Resolver<
    ResolversTypes['Account'],
    ParentType,
    ContextType,
    RequireFields<MutationUpdateAccountArgs, 'id' | 'input'>
  >;
  UpdateComment?: Resolver<
    ResolversTypes['Comment'],
    ParentType,
    ContextType,
    RequireFields<MutationUpdateCommentArgs, 'id' | 'input'>
  >;
  UpdateMarker?: Resolver<
    ResolversTypes['Marker'],
    ParentType,
    ContextType,
    RequireFields<MutationUpdateMarkerArgs, 'id' | 'input'>
  >;
  UpdatePost?: Resolver<
    ResolversTypes['Post'],
    ParentType,
    ContextType,
    RequireFields<MutationUpdatePostArgs, 'id' | 'input'>
  >;
  UpdateRequest?: Resolver<
    ResolversTypes['Request'],
    ParentType,
    ContextType,
    RequireFields<MutationUpdateRequestArgs, 'id' | 'input'>
  >;
  UpdateSession?: Resolver<
    ResolversTypes['Session'],
    ParentType,
    ContextType,
    RequireFields<MutationUpdateSessionArgs, 'id' | 'input'>
  >;
}>;

export type MuteResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['Mute'] = ResolversParentTypes['Mute'],
> = ResolversObject<{
  account?: Resolver<ResolversTypes['Account'], ParentType, ContextType>;
  accountID?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  mute?: Resolver<ResolversTypes['Account'], ParentType, ContextType>;
  muteID?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type NodeResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node'],
> = ResolversObject<{
  __resolveType: TypeResolveFn<
    | 'Account'
    | 'Comment'
    | 'Friend'
    | 'Like'
    | 'Marker'
    | 'Mute'
    | 'Post'
    | 'Request'
    | 'Session',
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
}>;

export type PageInfoResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['PageInfo'] = ResolversParentTypes['PageInfo'],
> = ResolversObject<{
  endCursor?: Resolver<
    Maybe<ResolversTypes['Cursor']>,
    ParentType,
    ContextType
  >;
  hasNextPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasPreviousPage?: Resolver<
    ResolversTypes['Boolean'],
    ParentType,
    ContextType
  >;
  startCursor?: Resolver<
    Maybe<ResolversTypes['Cursor']>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PostResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['Post'] = ResolversParentTypes['Post'],
> = ResolversObject<{
  account?: Resolver<ResolversTypes['Account'], ParentType, ContextType>;
  accountID?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  comments?: Resolver<
    Maybe<Array<ResolversTypes['Comment']>>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  img?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  likes?: Resolver<
    Maybe<Array<ResolversTypes['Like']>>,
    ParentType,
    ContextType
  >;
  marker?: Resolver<Maybe<ResolversTypes['Marker']>, ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type QueryResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query'],
> = ResolversObject<{
  AccountByID?: Resolver<
    ResolversTypes['Account'],
    ParentType,
    ContextType,
    RequireFields<QueryAccountByIdArgs, 'id'>
  >;
  AccountBySelfID?: Resolver<
    ResolversTypes['Account'],
    ParentType,
    ContextType,
    RequireFields<QueryAccountBySelfIdArgs, 'id'>
  >;
  LikesByPostID?: Resolver<
    Array<ResolversTypes['Like']>,
    ParentType,
    ContextType,
    RequireFields<QueryLikesByPostIdArgs, 'postID'>
  >;
  RequestsByAccountID?: Resolver<
    Array<ResolversTypes['Request']>,
    ParentType,
    ContextType,
    RequireFields<QueryRequestsByAccountIdArgs, 'accountID'>
  >;
  RequestsByRequestID?: Resolver<
    Array<ResolversTypes['Request']>,
    ParentType,
    ContextType,
    RequireFields<QueryRequestsByRequestIdArgs, 'requestID'>
  >;
  SessionByID?: Resolver<
    ResolversTypes['Session'],
    ParentType,
    ContextType,
    RequireFields<QuerySessionByIdArgs, 'id'>
  >;
  accounts?: Resolver<
    Array<ResolversTypes['Account']>,
    ParentType,
    ContextType
  >;
  comments?: Resolver<
    Array<ResolversTypes['Comment']>,
    ParentType,
    ContextType
  >;
  friends?: Resolver<Array<ResolversTypes['Friend']>, ParentType, ContextType>;
  likes?: Resolver<Array<ResolversTypes['Like']>, ParentType, ContextType>;
  markers?: Resolver<Array<ResolversTypes['Marker']>, ParentType, ContextType>;
  mutes?: Resolver<Array<ResolversTypes['Mute']>, ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes['Node']>,
    ParentType,
    ContextType,
    RequireFields<QueryNodeArgs, 'id'>
  >;
  nodes?: Resolver<
    Array<Maybe<ResolversTypes['Node']>>,
    ParentType,
    ContextType,
    RequireFields<QueryNodesArgs, 'ids'>
  >;
  posts?: Resolver<Array<ResolversTypes['Post']>, ParentType, ContextType>;
  requests?: Resolver<
    Array<ResolversTypes['Request']>,
    ParentType,
    ContextType
  >;
  sessions?: Resolver<
    Array<ResolversTypes['Session']>,
    ParentType,
    ContextType
  >;
}>;

export type RequestResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['Request'] = ResolversParentTypes['Request'],
> = ResolversObject<{
  account?: Resolver<ResolversTypes['Account'], ParentType, ContextType>;
  accountID?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  request?: Resolver<ResolversTypes['Account'], ParentType, ContextType>;
  requestID?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  status?: Resolver<ResolversTypes['RequestStatus'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SessionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['Session'] = ResolversParentTypes['Session'],
> = ResolversObject<{
  account?: Resolver<ResolversTypes['Account'], ParentType, ContextType>;
  accountID?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  session?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface TimeScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes['Time'], any> {
  name: 'Time';
}

export interface UploadScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes['Upload'], any> {
  name: 'Upload';
}

export type Resolvers<ContextType = any> = ResolversObject<{
  Account?: AccountResolvers<ContextType>;
  Comment?: CommentResolvers<ContextType>;
  Cursor?: GraphQLScalarType;
  Friend?: FriendResolvers<ContextType>;
  Like?: LikeResolvers<ContextType>;
  Marker?: MarkerResolvers<ContextType>;
  Mutation?: MutationResolvers<ContextType>;
  Mute?: MuteResolvers<ContextType>;
  Node?: NodeResolvers<ContextType>;
  PageInfo?: PageInfoResolvers<ContextType>;
  Post?: PostResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  Request?: RequestResolvers<ContextType>;
  Session?: SessionResolvers<ContextType>;
  Time?: GraphQLScalarType;
  Upload?: GraphQLScalarType;
}>;

export type DirectiveResolvers<ContextType = any> = ResolversObject<{
  goField?: GoFieldDirectiveResolver<any, any, ContextType>;
  goModel?: GoModelDirectiveResolver<any, any, ContextType>;
}>;
