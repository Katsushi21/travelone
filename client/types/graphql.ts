/* eslint-disable */
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  Cursor: unknown;
  Time: unknown;
  Upload: unknown;
};

export type Account = Node & {
  readonly age: Scalars['Int'];
  readonly avatar: Scalars['String'];
  readonly comments: Maybe<ReadonlyArray<Comment>>;
  readonly createdAt: Scalars['Time'];
  readonly email: Scalars['String'];
  readonly friends: Maybe<ReadonlyArray<Account>>;
  readonly friendship: Maybe<ReadonlyArray<Friend>>;
  readonly gender: AccountGender;
  readonly id: Scalars['ID'];
  readonly introduction: Scalars['String'];
  readonly likes: Maybe<ReadonlyArray<Like>>;
  readonly mutes: Maybe<ReadonlyArray<Account>>;
  readonly mutetarget: Maybe<ReadonlyArray<Mute>>;
  readonly name: Scalars['String'];
  readonly password: Scalars['String'];
  readonly posts: Maybe<ReadonlyArray<Post>>;
  readonly requests: Maybe<ReadonlyArray<Account>>;
  readonly requesttarget: Maybe<ReadonlyArray<Request>>;
  readonly session: Maybe<ReadonlyArray<Session>>;
  readonly type: AccountType;
  readonly updatedAt: Scalars['Time'];
};

/** AccountGender is enum for the field gender */
export const AccountGender = {
  Female: 'FEMALE',
  Male: 'MALE',
  None: 'NONE',
} as const;

export type AccountGender = typeof AccountGender[keyof typeof AccountGender];
/** AccountType is enum for the field type */
export const AccountType = {
  Active: 'ACTIVE',
  Admin: 'ADMIN',
  Inactive: 'INACTIVE',
} as const;

export type AccountType = typeof AccountType[keyof typeof AccountType];
/**
 * AccountWhereInput is used for filtering Account objects.
 * Input was generated by ent.
 */
export type AccountWhereInput = {
  /** age field predicates */
  readonly age: InputMaybe<Scalars['Int']>;
  readonly ageGT: InputMaybe<Scalars['Int']>;
  readonly ageGTE: InputMaybe<Scalars['Int']>;
  readonly ageIn: InputMaybe<ReadonlyArray<Scalars['Int']>>;
  readonly ageLT: InputMaybe<Scalars['Int']>;
  readonly ageLTE: InputMaybe<Scalars['Int']>;
  readonly ageNEQ: InputMaybe<Scalars['Int']>;
  readonly ageNotIn: InputMaybe<ReadonlyArray<Scalars['Int']>>;
  readonly and: InputMaybe<ReadonlyArray<AccountWhereInput>>;
  /** avatar field predicates */
  readonly avatar: InputMaybe<Scalars['String']>;
  readonly avatarContains: InputMaybe<Scalars['String']>;
  readonly avatarContainsFold: InputMaybe<Scalars['String']>;
  readonly avatarEqualFold: InputMaybe<Scalars['String']>;
  readonly avatarGT: InputMaybe<Scalars['String']>;
  readonly avatarGTE: InputMaybe<Scalars['String']>;
  readonly avatarHasPrefix: InputMaybe<Scalars['String']>;
  readonly avatarHasSuffix: InputMaybe<Scalars['String']>;
  readonly avatarIn: InputMaybe<ReadonlyArray<Scalars['String']>>;
  readonly avatarLT: InputMaybe<Scalars['String']>;
  readonly avatarLTE: InputMaybe<Scalars['String']>;
  readonly avatarNEQ: InputMaybe<Scalars['String']>;
  readonly avatarNotIn: InputMaybe<ReadonlyArray<Scalars['String']>>;
  /** created_at field predicates */
  readonly createdAt: InputMaybe<Scalars['Time']>;
  readonly createdAtGT: InputMaybe<Scalars['Time']>;
  readonly createdAtGTE: InputMaybe<Scalars['Time']>;
  readonly createdAtIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  readonly createdAtLT: InputMaybe<Scalars['Time']>;
  readonly createdAtLTE: InputMaybe<Scalars['Time']>;
  readonly createdAtNEQ: InputMaybe<Scalars['Time']>;
  readonly createdAtNotIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  /** email field predicates */
  readonly email: InputMaybe<Scalars['String']>;
  readonly emailContains: InputMaybe<Scalars['String']>;
  readonly emailContainsFold: InputMaybe<Scalars['String']>;
  readonly emailEqualFold: InputMaybe<Scalars['String']>;
  readonly emailGT: InputMaybe<Scalars['String']>;
  readonly emailGTE: InputMaybe<Scalars['String']>;
  readonly emailHasPrefix: InputMaybe<Scalars['String']>;
  readonly emailHasSuffix: InputMaybe<Scalars['String']>;
  readonly emailIn: InputMaybe<ReadonlyArray<Scalars['String']>>;
  readonly emailLT: InputMaybe<Scalars['String']>;
  readonly emailLTE: InputMaybe<Scalars['String']>;
  readonly emailNEQ: InputMaybe<Scalars['String']>;
  readonly emailNotIn: InputMaybe<ReadonlyArray<Scalars['String']>>;
  /** gender field predicates */
  readonly gender: InputMaybe<AccountGender>;
  readonly genderIn: InputMaybe<ReadonlyArray<AccountGender>>;
  readonly genderNEQ: InputMaybe<AccountGender>;
  readonly genderNotIn: InputMaybe<ReadonlyArray<AccountGender>>;
  /** comments edge predicates */
  readonly hasComments: InputMaybe<Scalars['Boolean']>;
  readonly hasCommentsWith: InputMaybe<ReadonlyArray<CommentWhereInput>>;
  /** friends edge predicates */
  readonly hasFriends: InputMaybe<Scalars['Boolean']>;
  readonly hasFriendsWith: InputMaybe<ReadonlyArray<AccountWhereInput>>;
  /** friendship edge predicates */
  readonly hasFriendship: InputMaybe<Scalars['Boolean']>;
  readonly hasFriendshipWith: InputMaybe<ReadonlyArray<FriendWhereInput>>;
  /** likes edge predicates */
  readonly hasLikes: InputMaybe<Scalars['Boolean']>;
  readonly hasLikesWith: InputMaybe<ReadonlyArray<LikeWhereInput>>;
  /** muteTarget edge predicates */
  readonly hasMuteTarget: InputMaybe<Scalars['Boolean']>;
  readonly hasMuteTargetWith: InputMaybe<ReadonlyArray<MuteWhereInput>>;
  /** mutes edge predicates */
  readonly hasMutes: InputMaybe<Scalars['Boolean']>;
  readonly hasMutesWith: InputMaybe<ReadonlyArray<AccountWhereInput>>;
  /** posts edge predicates */
  readonly hasPosts: InputMaybe<Scalars['Boolean']>;
  readonly hasPostsWith: InputMaybe<ReadonlyArray<PostWhereInput>>;
  /** requestTarget edge predicates */
  readonly hasRequestTarget: InputMaybe<Scalars['Boolean']>;
  readonly hasRequestTargetWith: InputMaybe<ReadonlyArray<RequestWhereInput>>;
  /** requests edge predicates */
  readonly hasRequests: InputMaybe<Scalars['Boolean']>;
  readonly hasRequestsWith: InputMaybe<ReadonlyArray<AccountWhereInput>>;
  /** session edge predicates */
  readonly hasSession: InputMaybe<Scalars['Boolean']>;
  readonly hasSessionWith: InputMaybe<ReadonlyArray<SessionWhereInput>>;
  /** id field predicates */
  readonly id: InputMaybe<Scalars['ID']>;
  readonly idGT: InputMaybe<Scalars['ID']>;
  readonly idGTE: InputMaybe<Scalars['ID']>;
  readonly idIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly idLT: InputMaybe<Scalars['ID']>;
  readonly idLTE: InputMaybe<Scalars['ID']>;
  readonly idNEQ: InputMaybe<Scalars['ID']>;
  readonly idNotIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  /** introduction field predicates */
  readonly introduction: InputMaybe<Scalars['String']>;
  readonly introductionContains: InputMaybe<Scalars['String']>;
  readonly introductionContainsFold: InputMaybe<Scalars['String']>;
  readonly introductionEqualFold: InputMaybe<Scalars['String']>;
  readonly introductionGT: InputMaybe<Scalars['String']>;
  readonly introductionGTE: InputMaybe<Scalars['String']>;
  readonly introductionHasPrefix: InputMaybe<Scalars['String']>;
  readonly introductionHasSuffix: InputMaybe<Scalars['String']>;
  readonly introductionIn: InputMaybe<ReadonlyArray<Scalars['String']>>;
  readonly introductionLT: InputMaybe<Scalars['String']>;
  readonly introductionLTE: InputMaybe<Scalars['String']>;
  readonly introductionNEQ: InputMaybe<Scalars['String']>;
  readonly introductionNotIn: InputMaybe<ReadonlyArray<Scalars['String']>>;
  /** name field predicates */
  readonly name: InputMaybe<Scalars['String']>;
  readonly nameContains: InputMaybe<Scalars['String']>;
  readonly nameContainsFold: InputMaybe<Scalars['String']>;
  readonly nameEqualFold: InputMaybe<Scalars['String']>;
  readonly nameGT: InputMaybe<Scalars['String']>;
  readonly nameGTE: InputMaybe<Scalars['String']>;
  readonly nameHasPrefix: InputMaybe<Scalars['String']>;
  readonly nameHasSuffix: InputMaybe<Scalars['String']>;
  readonly nameIn: InputMaybe<ReadonlyArray<Scalars['String']>>;
  readonly nameLT: InputMaybe<Scalars['String']>;
  readonly nameLTE: InputMaybe<Scalars['String']>;
  readonly nameNEQ: InputMaybe<Scalars['String']>;
  readonly nameNotIn: InputMaybe<ReadonlyArray<Scalars['String']>>;
  readonly not: InputMaybe<AccountWhereInput>;
  readonly or: InputMaybe<ReadonlyArray<AccountWhereInput>>;
  /** password field predicates */
  readonly password: InputMaybe<Scalars['String']>;
  readonly passwordContains: InputMaybe<Scalars['String']>;
  readonly passwordContainsFold: InputMaybe<Scalars['String']>;
  readonly passwordEqualFold: InputMaybe<Scalars['String']>;
  readonly passwordGT: InputMaybe<Scalars['String']>;
  readonly passwordGTE: InputMaybe<Scalars['String']>;
  readonly passwordHasPrefix: InputMaybe<Scalars['String']>;
  readonly passwordHasSuffix: InputMaybe<Scalars['String']>;
  readonly passwordIn: InputMaybe<ReadonlyArray<Scalars['String']>>;
  readonly passwordLT: InputMaybe<Scalars['String']>;
  readonly passwordLTE: InputMaybe<Scalars['String']>;
  readonly passwordNEQ: InputMaybe<Scalars['String']>;
  readonly passwordNotIn: InputMaybe<ReadonlyArray<Scalars['String']>>;
  /** type field predicates */
  readonly type: InputMaybe<AccountType>;
  readonly typeIn: InputMaybe<ReadonlyArray<AccountType>>;
  readonly typeNEQ: InputMaybe<AccountType>;
  readonly typeNotIn: InputMaybe<ReadonlyArray<AccountType>>;
  /** updated_at field predicates */
  readonly updatedAt: InputMaybe<Scalars['Time']>;
  readonly updatedAtGT: InputMaybe<Scalars['Time']>;
  readonly updatedAtGTE: InputMaybe<Scalars['Time']>;
  readonly updatedAtIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  readonly updatedAtLT: InputMaybe<Scalars['Time']>;
  readonly updatedAtLTE: InputMaybe<Scalars['Time']>;
  readonly updatedAtNEQ: InputMaybe<Scalars['Time']>;
  readonly updatedAtNotIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
};

export type Comment = Node & {
  readonly account: Account;
  readonly accountID: Scalars['ID'];
  readonly body: Scalars['String'];
  readonly createdAt: Scalars['Time'];
  readonly id: Scalars['ID'];
  readonly post: Post;
  readonly postID: Scalars['ID'];
  readonly updatedAt: Scalars['Time'];
};

/**
 * CommentWhereInput is used for filtering Comment objects.
 * Input was generated by ent.
 */
export type CommentWhereInput = {
  /** account_id field predicates */
  readonly accountID: InputMaybe<Scalars['ID']>;
  readonly accountIDIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly accountIDNEQ: InputMaybe<Scalars['ID']>;
  readonly accountIDNotIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly and: InputMaybe<ReadonlyArray<CommentWhereInput>>;
  /** body field predicates */
  readonly body: InputMaybe<Scalars['String']>;
  readonly bodyContains: InputMaybe<Scalars['String']>;
  readonly bodyContainsFold: InputMaybe<Scalars['String']>;
  readonly bodyEqualFold: InputMaybe<Scalars['String']>;
  readonly bodyGT: InputMaybe<Scalars['String']>;
  readonly bodyGTE: InputMaybe<Scalars['String']>;
  readonly bodyHasPrefix: InputMaybe<Scalars['String']>;
  readonly bodyHasSuffix: InputMaybe<Scalars['String']>;
  readonly bodyIn: InputMaybe<ReadonlyArray<Scalars['String']>>;
  readonly bodyLT: InputMaybe<Scalars['String']>;
  readonly bodyLTE: InputMaybe<Scalars['String']>;
  readonly bodyNEQ: InputMaybe<Scalars['String']>;
  readonly bodyNotIn: InputMaybe<ReadonlyArray<Scalars['String']>>;
  /** created_at field predicates */
  readonly createdAt: InputMaybe<Scalars['Time']>;
  readonly createdAtGT: InputMaybe<Scalars['Time']>;
  readonly createdAtGTE: InputMaybe<Scalars['Time']>;
  readonly createdAtIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  readonly createdAtLT: InputMaybe<Scalars['Time']>;
  readonly createdAtLTE: InputMaybe<Scalars['Time']>;
  readonly createdAtNEQ: InputMaybe<Scalars['Time']>;
  readonly createdAtNotIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  /** account edge predicates */
  readonly hasAccount: InputMaybe<Scalars['Boolean']>;
  readonly hasAccountWith: InputMaybe<ReadonlyArray<AccountWhereInput>>;
  /** post edge predicates */
  readonly hasPost: InputMaybe<Scalars['Boolean']>;
  readonly hasPostWith: InputMaybe<ReadonlyArray<PostWhereInput>>;
  /** id field predicates */
  readonly id: InputMaybe<Scalars['ID']>;
  readonly idGT: InputMaybe<Scalars['ID']>;
  readonly idGTE: InputMaybe<Scalars['ID']>;
  readonly idIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly idLT: InputMaybe<Scalars['ID']>;
  readonly idLTE: InputMaybe<Scalars['ID']>;
  readonly idNEQ: InputMaybe<Scalars['ID']>;
  readonly idNotIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly not: InputMaybe<CommentWhereInput>;
  readonly or: InputMaybe<ReadonlyArray<CommentWhereInput>>;
  /** post_id field predicates */
  readonly postID: InputMaybe<Scalars['ID']>;
  readonly postIDIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly postIDNEQ: InputMaybe<Scalars['ID']>;
  readonly postIDNotIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  /** updated_at field predicates */
  readonly updatedAt: InputMaybe<Scalars['Time']>;
  readonly updatedAtGT: InputMaybe<Scalars['Time']>;
  readonly updatedAtGTE: InputMaybe<Scalars['Time']>;
  readonly updatedAtIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  readonly updatedAtLT: InputMaybe<Scalars['Time']>;
  readonly updatedAtLTE: InputMaybe<Scalars['Time']>;
  readonly updatedAtNEQ: InputMaybe<Scalars['Time']>;
  readonly updatedAtNotIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
};

/**
 * CreateAccountInput is used for create Account object.
 * Input was generated by ent.
 */
export type CreateAccountInput = {
  readonly age: Scalars['Int'];
  readonly avatar: Scalars['String'];
  readonly commentIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly createdAt: InputMaybe<Scalars['Time']>;
  readonly email: Scalars['String'];
  readonly friendIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly gender: AccountGender;
  readonly introduction: Scalars['String'];
  readonly likeIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly muteIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly name: Scalars['String'];
  readonly password: Scalars['String'];
  readonly postIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly requestIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly sessionIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly type: AccountType;
  readonly updatedAt: InputMaybe<Scalars['Time']>;
};

/**
 * CreateCommentInput is used for create Comment object.
 * Input was generated by ent.
 */
export type CreateCommentInput = {
  readonly accountID: Scalars['ID'];
  readonly body: Scalars['String'];
  readonly createdAt: InputMaybe<Scalars['Time']>;
  readonly postID: Scalars['ID'];
  readonly updatedAt: InputMaybe<Scalars['Time']>;
};

/**
 * CreateFriendInput is used for create Friend object.
 * Input was generated by ent.
 */
export type CreateFriendInput = {
  readonly accountID: Scalars['ID'];
  readonly createdAt: InputMaybe<Scalars['Time']>;
  readonly friendID: Scalars['ID'];
  readonly updatedAt: InputMaybe<Scalars['Time']>;
};

/**
 * CreateLikeInput is used for create Like object.
 * Input was generated by ent.
 */
export type CreateLikeInput = {
  readonly accountID: Scalars['ID'];
  readonly createdAt: InputMaybe<Scalars['Time']>;
  readonly postID: Scalars['ID'];
  readonly updatedAt: InputMaybe<Scalars['Time']>;
};

/**
 * CreateMarkerInput is used for create Marker object.
 * Input was generated by ent.
 */
export type CreateMarkerInput = {
  readonly createdAt: InputMaybe<Scalars['Time']>;
  readonly lat: Scalars['String'];
  readonly lng: Scalars['String'];
  readonly postID: Scalars['ID'];
  readonly title: Scalars['String'];
  readonly updatedAt: InputMaybe<Scalars['Time']>;
};

/**
 * CreateMuteInput is used for create Mute object.
 * Input was generated by ent.
 */
export type CreateMuteInput = {
  readonly accountID: Scalars['ID'];
  readonly createdAt: InputMaybe<Scalars['Time']>;
  readonly muteID: Scalars['ID'];
  readonly updatedAt: InputMaybe<Scalars['Time']>;
};

/**
 * CreatePostInput is used for create Post object.
 * Input was generated by ent.
 */
export type CreatePostInput = {
  readonly accountID: Scalars['ID'];
  readonly body: Scalars['String'];
  readonly commentIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly createdAt: InputMaybe<Scalars['Time']>;
  readonly img: Scalars['String'];
  readonly likeIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly markerID: InputMaybe<Scalars['ID']>;
  readonly title: Scalars['String'];
  readonly updatedAt: InputMaybe<Scalars['Time']>;
};

/**
 * CreateRequestInput is used for create Request object.
 * Input was generated by ent.
 */
export type CreateRequestInput = {
  readonly accountID: Scalars['ID'];
  readonly createdAt: InputMaybe<Scalars['Time']>;
  readonly requestID: Scalars['ID'];
  readonly status: RequestStatus;
  readonly updatedAt: InputMaybe<Scalars['Time']>;
};

/**
 * CreateSessionInput is used for create Session object.
 * Input was generated by ent.
 */
export type CreateSessionInput = {
  readonly accountID: Scalars['ID'];
  readonly createdAt: InputMaybe<Scalars['Time']>;
  readonly session: Scalars['String'];
  readonly updatedAt: InputMaybe<Scalars['Time']>;
};

export type Friend = Node & {
  readonly account: Account;
  readonly accountID: Scalars['ID'];
  readonly createdAt: Scalars['Time'];
  readonly friend: Account;
  readonly friendID: Scalars['ID'];
  readonly id: Scalars['ID'];
  readonly updatedAt: Scalars['Time'];
};

/**
 * FriendWhereInput is used for filtering Friend objects.
 * Input was generated by ent.
 */
export type FriendWhereInput = {
  readonly and: InputMaybe<ReadonlyArray<FriendWhereInput>>;
  /** created_at field predicates */
  readonly createdAt: InputMaybe<Scalars['Time']>;
  readonly createdAtGT: InputMaybe<Scalars['Time']>;
  readonly createdAtGTE: InputMaybe<Scalars['Time']>;
  readonly createdAtIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  readonly createdAtLT: InputMaybe<Scalars['Time']>;
  readonly createdAtLTE: InputMaybe<Scalars['Time']>;
  readonly createdAtNEQ: InputMaybe<Scalars['Time']>;
  readonly createdAtNotIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  /** id field predicates */
  readonly id: InputMaybe<Scalars['ID']>;
  readonly idGT: InputMaybe<Scalars['ID']>;
  readonly idGTE: InputMaybe<Scalars['ID']>;
  readonly idIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly idLT: InputMaybe<Scalars['ID']>;
  readonly idLTE: InputMaybe<Scalars['ID']>;
  readonly idNEQ: InputMaybe<Scalars['ID']>;
  readonly idNotIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly not: InputMaybe<FriendWhereInput>;
  readonly or: InputMaybe<ReadonlyArray<FriendWhereInput>>;
  /** updated_at field predicates */
  readonly updatedAt: InputMaybe<Scalars['Time']>;
  readonly updatedAtGT: InputMaybe<Scalars['Time']>;
  readonly updatedAtGTE: InputMaybe<Scalars['Time']>;
  readonly updatedAtIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  readonly updatedAtLT: InputMaybe<Scalars['Time']>;
  readonly updatedAtLTE: InputMaybe<Scalars['Time']>;
  readonly updatedAtNEQ: InputMaybe<Scalars['Time']>;
  readonly updatedAtNotIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
};

export type Like = Node & {
  readonly account: Account;
  readonly accountID: Scalars['ID'];
  readonly createdAt: Scalars['Time'];
  readonly id: Scalars['ID'];
  readonly post: Post;
  readonly postID: Scalars['ID'];
  readonly updatedAt: Scalars['Time'];
};

/**
 * LikeWhereInput is used for filtering Like objects.
 * Input was generated by ent.
 */
export type LikeWhereInput = {
  /** account_id field predicates */
  readonly accountID: InputMaybe<Scalars['ID']>;
  readonly accountIDIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly accountIDNEQ: InputMaybe<Scalars['ID']>;
  readonly accountIDNotIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly and: InputMaybe<ReadonlyArray<LikeWhereInput>>;
  /** created_at field predicates */
  readonly createdAt: InputMaybe<Scalars['Time']>;
  readonly createdAtGT: InputMaybe<Scalars['Time']>;
  readonly createdAtGTE: InputMaybe<Scalars['Time']>;
  readonly createdAtIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  readonly createdAtLT: InputMaybe<Scalars['Time']>;
  readonly createdAtLTE: InputMaybe<Scalars['Time']>;
  readonly createdAtNEQ: InputMaybe<Scalars['Time']>;
  readonly createdAtNotIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  /** account edge predicates */
  readonly hasAccount: InputMaybe<Scalars['Boolean']>;
  readonly hasAccountWith: InputMaybe<ReadonlyArray<AccountWhereInput>>;
  /** post edge predicates */
  readonly hasPost: InputMaybe<Scalars['Boolean']>;
  readonly hasPostWith: InputMaybe<ReadonlyArray<PostWhereInput>>;
  /** id field predicates */
  readonly id: InputMaybe<Scalars['ID']>;
  readonly idGT: InputMaybe<Scalars['ID']>;
  readonly idGTE: InputMaybe<Scalars['ID']>;
  readonly idIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly idLT: InputMaybe<Scalars['ID']>;
  readonly idLTE: InputMaybe<Scalars['ID']>;
  readonly idNEQ: InputMaybe<Scalars['ID']>;
  readonly idNotIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly not: InputMaybe<LikeWhereInput>;
  readonly or: InputMaybe<ReadonlyArray<LikeWhereInput>>;
  /** post_id field predicates */
  readonly postID: InputMaybe<Scalars['ID']>;
  readonly postIDIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly postIDNEQ: InputMaybe<Scalars['ID']>;
  readonly postIDNotIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  /** updated_at field predicates */
  readonly updatedAt: InputMaybe<Scalars['Time']>;
  readonly updatedAtGT: InputMaybe<Scalars['Time']>;
  readonly updatedAtGTE: InputMaybe<Scalars['Time']>;
  readonly updatedAtIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  readonly updatedAtLT: InputMaybe<Scalars['Time']>;
  readonly updatedAtLTE: InputMaybe<Scalars['Time']>;
  readonly updatedAtNEQ: InputMaybe<Scalars['Time']>;
  readonly updatedAtNotIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
};

export type Marker = Node & {
  readonly createdAt: Scalars['Time'];
  readonly id: Scalars['ID'];
  readonly lat: Scalars['String'];
  readonly lng: Scalars['String'];
  readonly post: Post;
  readonly postID: Scalars['ID'];
  readonly title: Scalars['String'];
  readonly updatedAt: Scalars['Time'];
};

/**
 * MarkerWhereInput is used for filtering Marker objects.
 * Input was generated by ent.
 */
export type MarkerWhereInput = {
  readonly and: InputMaybe<ReadonlyArray<MarkerWhereInput>>;
  /** created_at field predicates */
  readonly createdAt: InputMaybe<Scalars['Time']>;
  readonly createdAtGT: InputMaybe<Scalars['Time']>;
  readonly createdAtGTE: InputMaybe<Scalars['Time']>;
  readonly createdAtIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  readonly createdAtLT: InputMaybe<Scalars['Time']>;
  readonly createdAtLTE: InputMaybe<Scalars['Time']>;
  readonly createdAtNEQ: InputMaybe<Scalars['Time']>;
  readonly createdAtNotIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  /** post edge predicates */
  readonly hasPost: InputMaybe<Scalars['Boolean']>;
  readonly hasPostWith: InputMaybe<ReadonlyArray<PostWhereInput>>;
  /** id field predicates */
  readonly id: InputMaybe<Scalars['ID']>;
  readonly idGT: InputMaybe<Scalars['ID']>;
  readonly idGTE: InputMaybe<Scalars['ID']>;
  readonly idIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly idLT: InputMaybe<Scalars['ID']>;
  readonly idLTE: InputMaybe<Scalars['ID']>;
  readonly idNEQ: InputMaybe<Scalars['ID']>;
  readonly idNotIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  /** lat field predicates */
  readonly lat: InputMaybe<Scalars['String']>;
  readonly latContains: InputMaybe<Scalars['String']>;
  readonly latContainsFold: InputMaybe<Scalars['String']>;
  readonly latEqualFold: InputMaybe<Scalars['String']>;
  readonly latGT: InputMaybe<Scalars['String']>;
  readonly latGTE: InputMaybe<Scalars['String']>;
  readonly latHasPrefix: InputMaybe<Scalars['String']>;
  readonly latHasSuffix: InputMaybe<Scalars['String']>;
  readonly latIn: InputMaybe<ReadonlyArray<Scalars['String']>>;
  readonly latLT: InputMaybe<Scalars['String']>;
  readonly latLTE: InputMaybe<Scalars['String']>;
  readonly latNEQ: InputMaybe<Scalars['String']>;
  readonly latNotIn: InputMaybe<ReadonlyArray<Scalars['String']>>;
  /** lng field predicates */
  readonly lng: InputMaybe<Scalars['String']>;
  readonly lngContains: InputMaybe<Scalars['String']>;
  readonly lngContainsFold: InputMaybe<Scalars['String']>;
  readonly lngEqualFold: InputMaybe<Scalars['String']>;
  readonly lngGT: InputMaybe<Scalars['String']>;
  readonly lngGTE: InputMaybe<Scalars['String']>;
  readonly lngHasPrefix: InputMaybe<Scalars['String']>;
  readonly lngHasSuffix: InputMaybe<Scalars['String']>;
  readonly lngIn: InputMaybe<ReadonlyArray<Scalars['String']>>;
  readonly lngLT: InputMaybe<Scalars['String']>;
  readonly lngLTE: InputMaybe<Scalars['String']>;
  readonly lngNEQ: InputMaybe<Scalars['String']>;
  readonly lngNotIn: InputMaybe<ReadonlyArray<Scalars['String']>>;
  readonly not: InputMaybe<MarkerWhereInput>;
  readonly or: InputMaybe<ReadonlyArray<MarkerWhereInput>>;
  /** post_id field predicates */
  readonly postID: InputMaybe<Scalars['ID']>;
  readonly postIDIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly postIDNEQ: InputMaybe<Scalars['ID']>;
  readonly postIDNotIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  /** title field predicates */
  readonly title: InputMaybe<Scalars['String']>;
  readonly titleContains: InputMaybe<Scalars['String']>;
  readonly titleContainsFold: InputMaybe<Scalars['String']>;
  readonly titleEqualFold: InputMaybe<Scalars['String']>;
  readonly titleGT: InputMaybe<Scalars['String']>;
  readonly titleGTE: InputMaybe<Scalars['String']>;
  readonly titleHasPrefix: InputMaybe<Scalars['String']>;
  readonly titleHasSuffix: InputMaybe<Scalars['String']>;
  readonly titleIn: InputMaybe<ReadonlyArray<Scalars['String']>>;
  readonly titleLT: InputMaybe<Scalars['String']>;
  readonly titleLTE: InputMaybe<Scalars['String']>;
  readonly titleNEQ: InputMaybe<Scalars['String']>;
  readonly titleNotIn: InputMaybe<ReadonlyArray<Scalars['String']>>;
  /** updated_at field predicates */
  readonly updatedAt: InputMaybe<Scalars['Time']>;
  readonly updatedAtGT: InputMaybe<Scalars['Time']>;
  readonly updatedAtGTE: InputMaybe<Scalars['Time']>;
  readonly updatedAtIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  readonly updatedAtLT: InputMaybe<Scalars['Time']>;
  readonly updatedAtLTE: InputMaybe<Scalars['Time']>;
  readonly updatedAtNEQ: InputMaybe<Scalars['Time']>;
  readonly updatedAtNotIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
};

export type Mutation = {
  readonly CreateAccount: Account;
  readonly CreateComment: Comment;
  readonly CreateFriend: Friend;
  readonly CreateLike: Like;
  readonly CreateMarker: Marker;
  readonly CreateMute: Mute;
  readonly CreatePost: Post;
  readonly CreateRequest: Request;
  readonly CreateSession: Session;
  readonly DeleteAccount: Account;
  readonly DeleteComment: Comment;
  readonly DeleteFriend: Friend;
  readonly DeleteLike: Like;
  readonly DeleteMarker: Marker;
  readonly DeleteMute: Mute;
  readonly DeletePost: Post;
  readonly DeleteRequest: Request;
  readonly DeleteSession: Session;
  readonly UpdateAccount: Account;
  readonly UpdateComment: Comment;
  readonly UpdateMarker: Marker;
  readonly UpdatePost: Post;
  readonly UpdateRequest: Request;
  readonly UpdateSession: Session;
};

export type MutationCreateAccountArgs = {
  input: CreateAccountInput;
};

export type MutationCreateCommentArgs = {
  input: CreateCommentInput;
};

export type MutationCreateFriendArgs = {
  input: CreateFriendInput;
};

export type MutationCreateLikeArgs = {
  input: CreateLikeInput;
};

export type MutationCreateMarkerArgs = {
  input: CreateMarkerInput;
};

export type MutationCreateMuteArgs = {
  input: CreateMuteInput;
};

export type MutationCreatePostArgs = {
  input: CreatePostInput;
};

export type MutationCreateRequestArgs = {
  input: CreateRequestInput;
};

export type MutationCreateSessionArgs = {
  input: CreateSessionInput;
};

export type MutationDeleteAccountArgs = {
  id: Scalars['ID'];
};

export type MutationDeleteCommentArgs = {
  id: Scalars['ID'];
};

export type MutationDeleteFriendArgs = {
  id: Scalars['ID'];
};

export type MutationDeleteLikeArgs = {
  id: Scalars['ID'];
};

export type MutationDeleteMarkerArgs = {
  id: Scalars['ID'];
};

export type MutationDeleteMuteArgs = {
  id: Scalars['ID'];
};

export type MutationDeletePostArgs = {
  id: Scalars['ID'];
};

export type MutationDeleteRequestArgs = {
  id: Scalars['ID'];
};

export type MutationDeleteSessionArgs = {
  id: Scalars['ID'];
};

export type MutationUpdateAccountArgs = {
  id: Scalars['ID'];
  input: UpdateAccountInput;
};

export type MutationUpdateCommentArgs = {
  id: Scalars['ID'];
  input: UpdateCommentInput;
};

export type MutationUpdateMarkerArgs = {
  id: Scalars['ID'];
  input: UpdateMarkerInput;
};

export type MutationUpdatePostArgs = {
  id: Scalars['ID'];
  input: UpdatePostInput;
};

export type MutationUpdateRequestArgs = {
  id: Scalars['ID'];
  input: UpdateRequestInput;
};

export type MutationUpdateSessionArgs = {
  id: Scalars['ID'];
  input: UpdateSessionInput;
};

export type Mute = Node & {
  readonly account: Account;
  readonly accountID: Scalars['ID'];
  readonly createdAt: Scalars['Time'];
  readonly id: Scalars['ID'];
  readonly mute: Account;
  readonly muteID: Scalars['ID'];
  readonly updatedAt: Scalars['Time'];
};

/**
 * MuteWhereInput is used for filtering Mute objects.
 * Input was generated by ent.
 */
export type MuteWhereInput = {
  readonly and: InputMaybe<ReadonlyArray<MuteWhereInput>>;
  /** created_at field predicates */
  readonly createdAt: InputMaybe<Scalars['Time']>;
  readonly createdAtGT: InputMaybe<Scalars['Time']>;
  readonly createdAtGTE: InputMaybe<Scalars['Time']>;
  readonly createdAtIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  readonly createdAtLT: InputMaybe<Scalars['Time']>;
  readonly createdAtLTE: InputMaybe<Scalars['Time']>;
  readonly createdAtNEQ: InputMaybe<Scalars['Time']>;
  readonly createdAtNotIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  /** id field predicates */
  readonly id: InputMaybe<Scalars['ID']>;
  readonly idGT: InputMaybe<Scalars['ID']>;
  readonly idGTE: InputMaybe<Scalars['ID']>;
  readonly idIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly idLT: InputMaybe<Scalars['ID']>;
  readonly idLTE: InputMaybe<Scalars['ID']>;
  readonly idNEQ: InputMaybe<Scalars['ID']>;
  readonly idNotIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly not: InputMaybe<MuteWhereInput>;
  readonly or: InputMaybe<ReadonlyArray<MuteWhereInput>>;
  /** updated_at field predicates */
  readonly updatedAt: InputMaybe<Scalars['Time']>;
  readonly updatedAtGT: InputMaybe<Scalars['Time']>;
  readonly updatedAtGTE: InputMaybe<Scalars['Time']>;
  readonly updatedAtIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  readonly updatedAtLT: InputMaybe<Scalars['Time']>;
  readonly updatedAtLTE: InputMaybe<Scalars['Time']>;
  readonly updatedAtNEQ: InputMaybe<Scalars['Time']>;
  readonly updatedAtNotIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  readonly id: Scalars['ID'];
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export const OrderDirection = {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc: 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc: 'DESC',
} as const;

export type OrderDirection = typeof OrderDirection[keyof typeof OrderDirection];
/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  /** When paginating forwards, the cursor to continue. */
  readonly endCursor: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, are there more items? */
  readonly hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  readonly hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  readonly startCursor: Maybe<Scalars['Cursor']>;
};

export type Post = Node & {
  readonly account: Account;
  readonly accountID: Scalars['ID'];
  readonly body: Scalars['String'];
  readonly comments: Maybe<ReadonlyArray<Comment>>;
  readonly createdAt: Scalars['Time'];
  readonly id: Scalars['ID'];
  readonly img: Scalars['String'];
  readonly likes: Maybe<ReadonlyArray<Like>>;
  readonly marker: Maybe<Marker>;
  readonly title: Scalars['String'];
  readonly updatedAt: Scalars['Time'];
};

/**
 * PostWhereInput is used for filtering Post objects.
 * Input was generated by ent.
 */
export type PostWhereInput = {
  /** account_id field predicates */
  readonly accountID: InputMaybe<Scalars['ID']>;
  readonly accountIDIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly accountIDNEQ: InputMaybe<Scalars['ID']>;
  readonly accountIDNotIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly and: InputMaybe<ReadonlyArray<PostWhereInput>>;
  /** body field predicates */
  readonly body: InputMaybe<Scalars['String']>;
  readonly bodyContains: InputMaybe<Scalars['String']>;
  readonly bodyContainsFold: InputMaybe<Scalars['String']>;
  readonly bodyEqualFold: InputMaybe<Scalars['String']>;
  readonly bodyGT: InputMaybe<Scalars['String']>;
  readonly bodyGTE: InputMaybe<Scalars['String']>;
  readonly bodyHasPrefix: InputMaybe<Scalars['String']>;
  readonly bodyHasSuffix: InputMaybe<Scalars['String']>;
  readonly bodyIn: InputMaybe<ReadonlyArray<Scalars['String']>>;
  readonly bodyLT: InputMaybe<Scalars['String']>;
  readonly bodyLTE: InputMaybe<Scalars['String']>;
  readonly bodyNEQ: InputMaybe<Scalars['String']>;
  readonly bodyNotIn: InputMaybe<ReadonlyArray<Scalars['String']>>;
  /** created_at field predicates */
  readonly createdAt: InputMaybe<Scalars['Time']>;
  readonly createdAtGT: InputMaybe<Scalars['Time']>;
  readonly createdAtGTE: InputMaybe<Scalars['Time']>;
  readonly createdAtIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  readonly createdAtLT: InputMaybe<Scalars['Time']>;
  readonly createdAtLTE: InputMaybe<Scalars['Time']>;
  readonly createdAtNEQ: InputMaybe<Scalars['Time']>;
  readonly createdAtNotIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  /** account edge predicates */
  readonly hasAccount: InputMaybe<Scalars['Boolean']>;
  readonly hasAccountWith: InputMaybe<ReadonlyArray<AccountWhereInput>>;
  /** comments edge predicates */
  readonly hasComments: InputMaybe<Scalars['Boolean']>;
  readonly hasCommentsWith: InputMaybe<ReadonlyArray<CommentWhereInput>>;
  /** likes edge predicates */
  readonly hasLikes: InputMaybe<Scalars['Boolean']>;
  readonly hasLikesWith: InputMaybe<ReadonlyArray<LikeWhereInput>>;
  /** marker edge predicates */
  readonly hasMarker: InputMaybe<Scalars['Boolean']>;
  readonly hasMarkerWith: InputMaybe<ReadonlyArray<MarkerWhereInput>>;
  /** id field predicates */
  readonly id: InputMaybe<Scalars['ID']>;
  readonly idGT: InputMaybe<Scalars['ID']>;
  readonly idGTE: InputMaybe<Scalars['ID']>;
  readonly idIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly idLT: InputMaybe<Scalars['ID']>;
  readonly idLTE: InputMaybe<Scalars['ID']>;
  readonly idNEQ: InputMaybe<Scalars['ID']>;
  readonly idNotIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  /** img field predicates */
  readonly img: InputMaybe<Scalars['String']>;
  readonly imgContains: InputMaybe<Scalars['String']>;
  readonly imgContainsFold: InputMaybe<Scalars['String']>;
  readonly imgEqualFold: InputMaybe<Scalars['String']>;
  readonly imgGT: InputMaybe<Scalars['String']>;
  readonly imgGTE: InputMaybe<Scalars['String']>;
  readonly imgHasPrefix: InputMaybe<Scalars['String']>;
  readonly imgHasSuffix: InputMaybe<Scalars['String']>;
  readonly imgIn: InputMaybe<ReadonlyArray<Scalars['String']>>;
  readonly imgLT: InputMaybe<Scalars['String']>;
  readonly imgLTE: InputMaybe<Scalars['String']>;
  readonly imgNEQ: InputMaybe<Scalars['String']>;
  readonly imgNotIn: InputMaybe<ReadonlyArray<Scalars['String']>>;
  readonly not: InputMaybe<PostWhereInput>;
  readonly or: InputMaybe<ReadonlyArray<PostWhereInput>>;
  /** title field predicates */
  readonly title: InputMaybe<Scalars['String']>;
  readonly titleContains: InputMaybe<Scalars['String']>;
  readonly titleContainsFold: InputMaybe<Scalars['String']>;
  readonly titleEqualFold: InputMaybe<Scalars['String']>;
  readonly titleGT: InputMaybe<Scalars['String']>;
  readonly titleGTE: InputMaybe<Scalars['String']>;
  readonly titleHasPrefix: InputMaybe<Scalars['String']>;
  readonly titleHasSuffix: InputMaybe<Scalars['String']>;
  readonly titleIn: InputMaybe<ReadonlyArray<Scalars['String']>>;
  readonly titleLT: InputMaybe<Scalars['String']>;
  readonly titleLTE: InputMaybe<Scalars['String']>;
  readonly titleNEQ: InputMaybe<Scalars['String']>;
  readonly titleNotIn: InputMaybe<ReadonlyArray<Scalars['String']>>;
  /** updated_at field predicates */
  readonly updatedAt: InputMaybe<Scalars['Time']>;
  readonly updatedAtGT: InputMaybe<Scalars['Time']>;
  readonly updatedAtGTE: InputMaybe<Scalars['Time']>;
  readonly updatedAtIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  readonly updatedAtLT: InputMaybe<Scalars['Time']>;
  readonly updatedAtLTE: InputMaybe<Scalars['Time']>;
  readonly updatedAtNEQ: InputMaybe<Scalars['Time']>;
  readonly updatedAtNotIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
};

export type Query = {
  readonly AccountByID: Account;
  readonly AccountBySelfID: Account;
  readonly LikesByPostID: ReadonlyArray<Like>;
  readonly RequestsByAccountID: ReadonlyArray<Request>;
  readonly RequestsByRequestID: ReadonlyArray<Request>;
  readonly SessionByID: Session;
  readonly accounts: ReadonlyArray<Account>;
  readonly comments: ReadonlyArray<Comment>;
  readonly friends: ReadonlyArray<Friend>;
  readonly likes: ReadonlyArray<Like>;
  readonly markers: ReadonlyArray<Marker>;
  readonly mutes: ReadonlyArray<Mute>;
  /** Fetches an object given its ID. */
  readonly node: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  readonly nodes: ReadonlyArray<Maybe<Node>>;
  readonly posts: ReadonlyArray<Post>;
  readonly requests: ReadonlyArray<Request>;
  readonly sessions: ReadonlyArray<Session>;
};

export type QueryAccountByIdArgs = {
  id: Scalars['ID'];
};

export type QueryAccountBySelfIdArgs = {
  id: Scalars['ID'];
};

export type QueryLikesByPostIdArgs = {
  postID: Scalars['ID'];
};

export type QueryRequestsByAccountIdArgs = {
  accountID: Scalars['ID'];
};

export type QueryRequestsByRequestIdArgs = {
  requestID: Scalars['ID'];
};

export type QuerySessionByIdArgs = {
  id: Scalars['ID'];
};

export type QueryNodeArgs = {
  id: Scalars['ID'];
};

export type QueryNodesArgs = {
  ids: ReadonlyArray<Scalars['ID']>;
};

export type Request = Node & {
  readonly account: Account;
  readonly accountID: Scalars['ID'];
  readonly createdAt: Scalars['Time'];
  readonly id: Scalars['ID'];
  readonly request: Account;
  readonly requestID: Scalars['ID'];
  readonly status: RequestStatus;
  readonly updatedAt: Scalars['Time'];
};

/** RequestStatus is enum for the field status */
export const RequestStatus = {
  Accept: 'ACCEPT',
  BreakDeny: 'BREAK_DENY',
  BreakInAccept: 'BREAK_IN_ACCEPT',
  BreakInProcess: 'BREAK_IN_PROCESS',
  Deny: 'DENY',
  InProcess: 'IN_PROCESS',
} as const;

export type RequestStatus = typeof RequestStatus[keyof typeof RequestStatus];
/**
 * RequestWhereInput is used for filtering Request objects.
 * Input was generated by ent.
 */
export type RequestWhereInput = {
  readonly and: InputMaybe<ReadonlyArray<RequestWhereInput>>;
  /** created_at field predicates */
  readonly createdAt: InputMaybe<Scalars['Time']>;
  readonly createdAtGT: InputMaybe<Scalars['Time']>;
  readonly createdAtGTE: InputMaybe<Scalars['Time']>;
  readonly createdAtIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  readonly createdAtLT: InputMaybe<Scalars['Time']>;
  readonly createdAtLTE: InputMaybe<Scalars['Time']>;
  readonly createdAtNEQ: InputMaybe<Scalars['Time']>;
  readonly createdAtNotIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  /** id field predicates */
  readonly id: InputMaybe<Scalars['ID']>;
  readonly idGT: InputMaybe<Scalars['ID']>;
  readonly idGTE: InputMaybe<Scalars['ID']>;
  readonly idIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly idLT: InputMaybe<Scalars['ID']>;
  readonly idLTE: InputMaybe<Scalars['ID']>;
  readonly idNEQ: InputMaybe<Scalars['ID']>;
  readonly idNotIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly not: InputMaybe<RequestWhereInput>;
  readonly or: InputMaybe<ReadonlyArray<RequestWhereInput>>;
  /** status field predicates */
  readonly status: InputMaybe<RequestStatus>;
  readonly statusIn: InputMaybe<ReadonlyArray<RequestStatus>>;
  readonly statusNEQ: InputMaybe<RequestStatus>;
  readonly statusNotIn: InputMaybe<ReadonlyArray<RequestStatus>>;
  /** updated_at field predicates */
  readonly updatedAt: InputMaybe<Scalars['Time']>;
  readonly updatedAtGT: InputMaybe<Scalars['Time']>;
  readonly updatedAtGTE: InputMaybe<Scalars['Time']>;
  readonly updatedAtIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  readonly updatedAtLT: InputMaybe<Scalars['Time']>;
  readonly updatedAtLTE: InputMaybe<Scalars['Time']>;
  readonly updatedAtNEQ: InputMaybe<Scalars['Time']>;
  readonly updatedAtNotIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
};

export type Session = Node & {
  readonly account: Account;
  readonly accountID: Scalars['ID'];
  readonly createdAt: Scalars['Time'];
  readonly id: Scalars['ID'];
  readonly session: Scalars['String'];
  readonly updatedAt: Scalars['Time'];
};

/**
 * SessionWhereInput is used for filtering Session objects.
 * Input was generated by ent.
 */
export type SessionWhereInput = {
  /** account_id field predicates */
  readonly accountID: InputMaybe<Scalars['ID']>;
  readonly accountIDIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly accountIDNEQ: InputMaybe<Scalars['ID']>;
  readonly accountIDNotIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly and: InputMaybe<ReadonlyArray<SessionWhereInput>>;
  /** created_at field predicates */
  readonly createdAt: InputMaybe<Scalars['Time']>;
  readonly createdAtGT: InputMaybe<Scalars['Time']>;
  readonly createdAtGTE: InputMaybe<Scalars['Time']>;
  readonly createdAtIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  readonly createdAtLT: InputMaybe<Scalars['Time']>;
  readonly createdAtLTE: InputMaybe<Scalars['Time']>;
  readonly createdAtNEQ: InputMaybe<Scalars['Time']>;
  readonly createdAtNotIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  /** account edge predicates */
  readonly hasAccount: InputMaybe<Scalars['Boolean']>;
  readonly hasAccountWith: InputMaybe<ReadonlyArray<AccountWhereInput>>;
  /** id field predicates */
  readonly id: InputMaybe<Scalars['ID']>;
  readonly idGT: InputMaybe<Scalars['ID']>;
  readonly idGTE: InputMaybe<Scalars['ID']>;
  readonly idIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly idLT: InputMaybe<Scalars['ID']>;
  readonly idLTE: InputMaybe<Scalars['ID']>;
  readonly idNEQ: InputMaybe<Scalars['ID']>;
  readonly idNotIn: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly not: InputMaybe<SessionWhereInput>;
  readonly or: InputMaybe<ReadonlyArray<SessionWhereInput>>;
  /** session field predicates */
  readonly session: InputMaybe<Scalars['String']>;
  readonly sessionContains: InputMaybe<Scalars['String']>;
  readonly sessionContainsFold: InputMaybe<Scalars['String']>;
  readonly sessionEqualFold: InputMaybe<Scalars['String']>;
  readonly sessionGT: InputMaybe<Scalars['String']>;
  readonly sessionGTE: InputMaybe<Scalars['String']>;
  readonly sessionHasPrefix: InputMaybe<Scalars['String']>;
  readonly sessionHasSuffix: InputMaybe<Scalars['String']>;
  readonly sessionIn: InputMaybe<ReadonlyArray<Scalars['String']>>;
  readonly sessionLT: InputMaybe<Scalars['String']>;
  readonly sessionLTE: InputMaybe<Scalars['String']>;
  readonly sessionNEQ: InputMaybe<Scalars['String']>;
  readonly sessionNotIn: InputMaybe<ReadonlyArray<Scalars['String']>>;
  /** updated_at field predicates */
  readonly updatedAt: InputMaybe<Scalars['Time']>;
  readonly updatedAtGT: InputMaybe<Scalars['Time']>;
  readonly updatedAtGTE: InputMaybe<Scalars['Time']>;
  readonly updatedAtIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
  readonly updatedAtLT: InputMaybe<Scalars['Time']>;
  readonly updatedAtLTE: InputMaybe<Scalars['Time']>;
  readonly updatedAtNEQ: InputMaybe<Scalars['Time']>;
  readonly updatedAtNotIn: InputMaybe<ReadonlyArray<Scalars['Time']>>;
};

/**
 * UpdateAccountInput is used for update Account object.
 * Input was generated by ent.
 */
export type UpdateAccountInput = {
  readonly addCommentIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly addFriendIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly addLikeIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly addMuteIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly addPostIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly addRequestIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly addSessionIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly age: InputMaybe<Scalars['Int']>;
  readonly avatar: InputMaybe<Scalars['String']>;
  readonly email: InputMaybe<Scalars['String']>;
  readonly gender: InputMaybe<AccountGender>;
  readonly introduction: InputMaybe<Scalars['String']>;
  readonly name: InputMaybe<Scalars['String']>;
  readonly password: InputMaybe<Scalars['String']>;
  readonly removeCommentIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly removeFriendIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly removeLikeIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly removeMuteIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly removePostIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly removeRequestIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly removeSessionIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly type: InputMaybe<AccountType>;
  readonly updatedAt: InputMaybe<Scalars['Time']>;
};

/**
 * UpdateCommentInput is used for update Comment object.
 * Input was generated by ent.
 */
export type UpdateCommentInput = {
  readonly accountID: InputMaybe<Scalars['ID']>;
  readonly body: InputMaybe<Scalars['String']>;
  readonly clearAccount: InputMaybe<Scalars['Boolean']>;
  readonly clearPost: InputMaybe<Scalars['Boolean']>;
  readonly postID: InputMaybe<Scalars['ID']>;
  readonly updatedAt: InputMaybe<Scalars['Time']>;
};

/**
 * UpdateFriendInput is used for update Friend object.
 * Input was generated by ent.
 */
export type UpdateFriendInput = {
  readonly accountID: InputMaybe<Scalars['ID']>;
  readonly clearAccount: InputMaybe<Scalars['Boolean']>;
  readonly clearFriend: InputMaybe<Scalars['Boolean']>;
  readonly friendID: InputMaybe<Scalars['ID']>;
  readonly updatedAt: InputMaybe<Scalars['Time']>;
};

/**
 * UpdateLikeInput is used for update Like object.
 * Input was generated by ent.
 */
export type UpdateLikeInput = {
  readonly accountID: InputMaybe<Scalars['ID']>;
  readonly clearAccount: InputMaybe<Scalars['Boolean']>;
  readonly clearPost: InputMaybe<Scalars['Boolean']>;
  readonly postID: InputMaybe<Scalars['ID']>;
  readonly updatedAt: InputMaybe<Scalars['Time']>;
};

/**
 * UpdateMarkerInput is used for update Marker object.
 * Input was generated by ent.
 */
export type UpdateMarkerInput = {
  readonly clearPost: InputMaybe<Scalars['Boolean']>;
  readonly lat: InputMaybe<Scalars['String']>;
  readonly lng: InputMaybe<Scalars['String']>;
  readonly postID: InputMaybe<Scalars['ID']>;
  readonly title: InputMaybe<Scalars['String']>;
  readonly updatedAt: InputMaybe<Scalars['Time']>;
};

/**
 * UpdateMuteInput is used for update Mute object.
 * Input was generated by ent.
 */
export type UpdateMuteInput = {
  readonly accountID: InputMaybe<Scalars['ID']>;
  readonly clearAccount: InputMaybe<Scalars['Boolean']>;
  readonly clearMute: InputMaybe<Scalars['Boolean']>;
  readonly muteID: InputMaybe<Scalars['ID']>;
  readonly updatedAt: InputMaybe<Scalars['Time']>;
};

/**
 * UpdatePostInput is used for update Post object.
 * Input was generated by ent.
 */
export type UpdatePostInput = {
  readonly accountID: InputMaybe<Scalars['ID']>;
  readonly addCommentIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly addLikeIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly body: InputMaybe<Scalars['String']>;
  readonly clearAccount: InputMaybe<Scalars['Boolean']>;
  readonly clearMarker: InputMaybe<Scalars['Boolean']>;
  readonly img: InputMaybe<Scalars['String']>;
  readonly markerID: InputMaybe<Scalars['ID']>;
  readonly removeCommentIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly removeLikeIDs: InputMaybe<ReadonlyArray<Scalars['ID']>>;
  readonly title: InputMaybe<Scalars['String']>;
  readonly updatedAt: InputMaybe<Scalars['Time']>;
};

/**
 * UpdateRequestInput is used for update Request object.
 * Input was generated by ent.
 */
export type UpdateRequestInput = {
  readonly accountID: InputMaybe<Scalars['ID']>;
  readonly clearAccount: InputMaybe<Scalars['Boolean']>;
  readonly clearRequest: InputMaybe<Scalars['Boolean']>;
  readonly requestID: InputMaybe<Scalars['ID']>;
  readonly status: InputMaybe<RequestStatus>;
  readonly updatedAt: InputMaybe<Scalars['Time']>;
};

/**
 * UpdateSessionInput is used for update Session object.
 * Input was generated by ent.
 */
export type UpdateSessionInput = {
  readonly accountID: InputMaybe<Scalars['ID']>;
  readonly clearAccount: InputMaybe<Scalars['Boolean']>;
  readonly session: InputMaybe<Scalars['String']>;
  readonly updatedAt: InputMaybe<Scalars['Time']>;
};
